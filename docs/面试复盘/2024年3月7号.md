# 3 月 7 号面试题（蚂蚁金服 二面）

## 1. 自我介绍

## 2. 什么是跨域，一般怎么解决

**当一个请求 url 的`协议`、`域名`、`端口`三者之间的`任意一个`与当前页面 url`不同`即为`跨域`。**

出于浏览器的`同源策略`限制，是发生在 页面 到 服务端 请求的过程中

解决方法：

**nginx 反向代理解决跨域（前端常用）**

**4.CORS 解决跨域(也就是添加响应头解决跨域)**

浏览器先询问 b,b 允许 a 访问
access-control-allow-origin
access-control-max-age
PHP 端修改 header：
![image.png](https://segmentfault.com/img/bVc7B7J)

```awk
header('Access-Control-Allow-Origin:*');//允许所有来源访问
header('Access-Control-Allow-Method:POST,GET');//允许访问的方式
```

它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。

CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。

浏览器端：

目前，所有浏览器都支持该功能（IE10 以下不行）。整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。

服务端：

CORS 通信与 AJAX 没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否运行其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。

> **优势：**
>
> 在服务端进行控制是否允许跨域，可自定义规则
> 支持各种请求方式
>
> **缺点：**
>
> 会产生额外的请求

## 3. http 请求的状态码有哪些

200 OK：请求成功，服务器成功处理了请求。
201 Created：请求已成功，并在服务器上创建了新的资源。
204 No Content：服务器成功处理了请求，但没有返回任何内容。
301 Moved Permanently：永久移动。请求的资源已被永久的移动到新 URI。
302 Found：资源只是临时被移动。客户端应继续使用原有 URI。
400 Bad Request：服务器无法理解请求的语法，请求有语法错误。
401 Unauthorized：请求需要用户身份验证。
403 Forbidden：服务器拒绝请求，没有权限访问。
404 Not Found：请求的资源不存在。
405 Method Not Allowed：请求方法不被允许。
500 Internal Server Error：服务器内部错误，无法完成请求。
502 Bad Gateway：服务器作为网关或代理,从上游服务器收到无效响应。
503 Service Unavailable：服务器当前无法处理请求,通常由于过载或维护。

#### 1XX 消息状态码：

-   100：Continue 继续。客户端继续请求。
-   101：Swiching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议。

#### 2XX 成功状态码

-   **200：OK 请求成功。一般用于 GET 和 POST 请求。**
-   201：Created 已创建。成功请求并创建了新的资源。
-   202：Accepted 已接受。已经接受请求，但未处理完成。
-   203：Non-Authoritative Information 非授权信息。请求成功，但返回的 meta 信息不在原始的服务器，而是一个副本。
-   **204：No Content 无内容。服务器处理成功，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档。**
-   205：Reset Content 重置内容。服务器处理成功，用户终端（例如浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域。
-   **206：Partial Content 部分内容。服务器成功处理了部分 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。**

#### 3XX 重定向状态码

-   300：Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择。
-   **301：Moved Permanently 永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替。**
-   **302：Found 临时移动，与 301 类似。但资源只是临时被移动。客户端应继续使用原有 URI。**
-   303：See Other 查看其它地址。与 301 类似。使用 GET 和 POST 请求查看。
-   **304：Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。**
-   305：Use Proxy 使用代理。所请求的资源必须通过代理访问。
-   306：Unused 已经被废弃的 HTTP 状态码。
-   **307：Temporary Redirect 临时重定向。与 302 类似。使用 GET 请求重定向。**

#### 4XX 客户端错误状态码

-   **400：Bad Request 客户端请求的语法错误，服务器无法理解。**
-   **401：Unauthorized 请求要求用户的身份认证。**
-   **402：Payment Required 保留，将来使用。**
-   **403：Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求。**
-   **404：Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面。**
-   405：Method Not Allowed 客户端请求中的方法被禁止。
-   406：Not Acceptable 服务器无法根据客户端请求的内容特性完成请求。
-   407：Proxy Authentication Required 请求要求代理的身份认证，与 401 类似，但请求者应当使用代理进行授权。
-   408：Request Time-out 服务器等待客户端发送的请求时间过长，超时。
-   409：Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突。
-   410：Gone 客户端请求的资源已经不存在。410 不同于 404，如果资源以前有现在被永久删除了可使用 410 代码，网站设计人员可通过 301 代码指定资源的新位置。
-   411：Length Required 服务器无法处理客户端发送的不带 Content-Length 的请求信息。
-   412：Precondition Failed 客户端请求信息的先决条件错误。
-   413：Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个 Retry-After 的响应信息。
-   414：Request-URI Too Large 请求的 URI 过长（URI 通常为网址），服务器无法处理。
-   415：Unsupported Media Type 服务器无法处理请求附带的媒体格式。
-   416：Requested range not satisfiable 客户端请求的范围无效。
-   417：Expectation Failed 服务器无法满足 Expect 的请求头信息。

#### 5XX 服务端错误状态码

-   **500：Internal Server Error 服务器内部错误，无法完成请求。**
-   **501：Not Implemented 服务器不支持请求的功能，无法完成请求。**
-   502：Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。
-   **503：Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中。**
-   504：Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求。
-   505：HTTP Version not supported 服务器不支持请求的 HTTP 协议的版本，无法完成处理。

## 4. 箭头函数和普通函数的区别

https://juejin.cn/post/6844903805960585224

MDN 的描述：

箭头函数表达式的语法比传统的函数表达式更简洁，但在语义上有一些差异，在用法上也有一些限制：

-   箭头函数没有独立的 `this`、`arguments` 和 `super` 绑定，并且不可被用作方法。
-   箭头函数不能用作构造函数。使用 `new` 调用它们会引发 `TypeError`。它们也无法访问 `new.target` 关键字。
-   箭头函数不能在其主体中使用 `yield`，也不能作为生成器函数创建。

> 所谓的没有 this ，不是箭头函数中没有 this 这个变量，而是箭头函数不绑定自己的 this，它们会捕获其所在上下文的 this 值，作为自己的 this 值。这对于回调函数特别有用，可以避免传统函数中常见的 this 指向问题。例如，在对象方法中使用箭头函数可以确保 this 保持一致。

箭头函数是继承外层函数的this绑定

## 5. js 攻击 网络安全相关的

https://vue3js.cn/interview/JavaScript/security.html

https://codingwithalice.github.io/2021/05/07/XSS%E8%B7%A8%E5%9F%9F%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB-%E5%92%8C-CSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%94%BB%E5%87%BB/

### XSS 跨域脚本攻击 和 CSRF 跨站请求伪造攻击

-   总结

    1、**页面安全问题** 的主要原因就是浏览器为 **同源策略** 开的两个后门：

    -   页面中可以任意引用 第三方资源
    -   通过 CORS 策略让 `XMLHttpRequest` 和 `Fetch` 去 跨域 请求资源

    2、为了解决这些问题：

    -   引入了 **CSP 内容安全策略** 来限制页面任意引入外部资源
    -   引入了 `HttpOnly` 机制来禁止 `XMLHttpRequest` 或者 `Fetch` 发送一些关键 `Cookie`
    -   引入了 `SameSite` 和 `Origin` 来防止 CSRF 攻击

#### XSS 跨域脚本攻击

XSS 攻击 Cross Site Script ：即 **跨域脚本攻击**（为和 CSS 区分，改叫 XSS）

-   总结

    1、XSS 攻击就是黑客往页面中注入恶意脚本，使之在客户端运行，然后将页面的一些重要数据上传到恶意服务器

    2、常见的三种 XSS 攻击模式是 **存储型** XSS 攻击、**反射型** XSS 攻击和 **基于 DOM** 的 XSS 攻击

    -   **共同点**

        都是需要 **往用户的页面中注入恶意脚本**，然后再通过恶意脚本将用户数据上传到黑客的恶意服务器上

    -   **不同点**

        在于 **注入的方式不一样**，有通过服务器漏洞来进行注入的，还有在客户端直接注入的

    3、针对这些 XSS 攻击，主要有三种 **防范策略**

    -   1、通过 **服务器** 对输入的内容进行 **过滤或者转码**
    -   2、充分利用好 CSP 内容安全策略
    -   3、使用 `HttpOnly` 来保护重要的 Cookie 信息

##### 1、反射型 — 恶意链接

-   【简单描述】

    将用户输入的存在 XSS 攻击的数据，发送给后台，后台并未对数据进行存储，也未经过任何过滤，直接返回给客户端，被浏览器渲染

-   【具体步骤】

    1、构造出包含恶意代码的 url，url 指向目标网站，参数拼接恶意代码，举例如下：

    ![image-20210507105832153](https://codingwithalice.github.io/img/assets_2019/image-20210507105832153.png)

    2、诱导用户点击，点击后会向服务端发送请求，同时查询参数携带恶意代码

    3、服务端返回时 **将恶意代码直接拼接在 HTML**

    4、客户端接收并解析执行代码时，恶意代码也被执行

-   【特点】

    **需要攻击者诱使用户操作**：点击一个恶意链接/提交一个表单/进入一个恶意网站

-   【常见场景】

    通过 URL 传递参数的场景，如 **网站搜索、跳转**

##### 2、存储型

-   【简单描述】

    数据库中存有存在 XSS 攻击的数据，返回给客户端，数据未经任何转义被浏览器渲染

-   【具体步骤】

    1、把恶意代码提交到服务器端

    2、当浏览器向服务器请求数据时，**恶意代码拼接在 HTML 中** 从服务器传回

    3、客户端解析时被执行恶意代码，将用户 Cookie 信息等数据上传到恶意服务器

-   【特点】

    这种 XSS 攻击具有 **很强的稳定性**

-   【常见场景】

    **论坛发帖、商品评论、用户私信** 等，攻击者发布包含恶意 JS 代码的评论，所有访问的用户的浏览器中会被执行这段恶意的 JS 代码

    ![image-20210507110126121](https://codingwithalice.github.io/img/assets_2019/image-20210507110126121.png)

##### 3、基于 DOM 的 XSS 攻击

-   【特点】

    通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。

-   【可能性】

    1、`<script>` 标签

    2、a 标签的 `href`、`img` 上 `src`，例如：`<img src="javascript:alert('XSS')” />`

    3、`innerHTML/outerHTML=xx` 或 `setTimeout/setInterval` (执行 js)

    4、`document.write` 或 `eval`

    5、`location`、`onclick`、`onerror`、`onload`、`onmouseover `等事件（执行 js），例如：`<img src="#" onerror="alert('1')" />`

    6、在 style 属性中，包含类似 `background-image:url(“javascript:alert('XSS')”); `的代码（新版本浏览器已经可以防范）

    7、在 style 属性和标签中，包含类似 `expression(…)` 的 CSS 表达式代码(新版本浏览器已经可以防范)

##### XSS 攻击解决方案

无论是何种类型的 XSS 攻击，它们都有一个 **共同点**，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上

我们可以通过阻止【**恶意 JavaScript 脚本的注入**】和【**恶意消息的发送**】来实现

|                            **XSS 攻击解决方案**                             | **详细说明**                                                                                                                                                                               | **解决问题**                                                                                                             |
| :-------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------- |
|                           防范反射型、存储型 XSS                            | 1、采用纯前端渲染 2、拼接 HTML 时，要对 HTML 进行充分转义（过滤 `<script>` 标签，或者转码 `<script>` —> `<script>`）                                                                       | 即使这段脚本返回给页面，页面也不会执行这段脚本                                                                           |
|                               防范 DOM 型 XSS                               | 1、将用户输入插入 HTML 或拼接 js 执行时，要进行编码，将一些特殊字符转义 2、对于 a 标签的 href 等外链请求，添加 **白名单** 进行过滤，禁止以 `javascript:` 开头的链接，和其他非法的 `scheme` |                                                                                                                          |
|                              内容安全策略 CSP                               | 内置于浏览器，只信任 **白名单网站** 详解见下方                                                                                                                                             | 核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 `JavaScript` 代码，大大减少 XSS 攻击    |
| `HttpOnly` 标准 （防止劫取 Cookie） （HttpOnly 是服务器通过响应头来设置的） | 浏览器禁止页面的 JS 访问带有 `HttpOnly` 属性的 `Cookie`![image-20210507111719291](https://codingwithalice.github.io/img/assets_2019/image-20210507111719291.png)                           | 攻击者通过注入恶意脚本获取用户的 Cookie 信息，发起 Cookie 劫持攻击；HttpOnly **【阻止 XSS 攻击后的 Cookie 劫持攻击】**； |
|                        用户的输入检查 （XSS Filter）                        | 不要相信用户的任何输入，要进行检查、过滤和转义                                                                                                                                             | 检查用户输入中是否包含 <，> 等特殊字符，如果存在，则对特殊字符进行 **过滤或编码**                                        |
|                               服务端输出检查                                | 除富文本的输出外，在变量输出到 HTML 页面时，可以使用 **编码或转义** 的方式来防御 XSS 攻击                                                                                                  |                                                                                                                          |

##### 【踩坑汇总】内容安全策略 CSP

现在主流的浏览器内置了 CSP，它的实现/执行全部 **由浏览器完成**，开发者只需配置。

【CSP 实质】

**白名单制度**，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。

【CSP 作用】

-   **限制加载其他域下的资源文件**，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的
-   **禁止向第三方域提交数据**，这样用户数据也不会外泄
-   禁止执行 **内联脚本** 和 **未授权的脚本**
-   还提供了 **上报机制**，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题

启用后，不符合 CSP 的外部资源就会被阻止加载，报错截图如下：

![image-20210507112712103](https://codingwithalice.github.io/img/assets_2019/image-20210507112712103.png)

实际案例：

访问 `www.shemore.cn` 时，由于请求了 `m.beidianyx.com` 下的文件，出现了报错

![image-20210507112753156](https://codingwithalice.github.io/img/assets_2019/image-20210507112753156.png)

1、需要把当前域名配置入 `Content-Security-Policy` 中 比如水梦露官网的新域名：`www.shemore.cn` `m.beidianyx.com`。

2、如果 route 的配置的地址和当前页面路径不一致时，需要手动在 `controller` 中配置静态资源路径 `ctx.state.path`

【启用 CSP 的两种方法】

1、HTTP 响应头 **Content-Security-Policy**

![image-20210507112947501](https://codingwithalice.github.io/img/assets_2019/image-20210507112947501.png)

2、网页的 `<meta>` 标签

![image-20210507113015381](https://codingwithalice.github.io/img/assets_2019/image-20210507113015381.png)

|       属性值       |                                     描述                                      |
| :----------------: | :---------------------------------------------------------------------------: |
| default-src ‘self’ | 用来设置下面图中各个选项的默认值 **限制所有的外部资源，都只能从当前域名加载** |
| script-src ‘self’  |                             脚本：只信任当前域名                              |
|  child-src https:  |                    框架（frame）：必须使用 HTTPS 协议加载                     |
|     report-uri     |                   告诉浏览器，应该把注入行为报告给哪个网址                    |

#### 跨站请求伪造 CSRF

Cross Site Request Forgery，攻击者借助受害者的 Cookie **骗取服务器的信任以操作服务端数据**。

–> 改变在服务端的数据，而非窃取数据

-   总结

    1、要发起 CSRF 攻击需要具备三个条件

    -   目标站点存在【漏洞】
    -   用户要【**登录**】过目标站点
    -   黑客需要通过【**第三方站点**】发起攻击

    2、如何防止 CSRF 攻击，主要有三种方式：

    -   充分利用好 Cookie 的 `SameSite` 属性
    -   验证请求的 **来源站点**
    -   使用 CSRF Token

-   【特点】

    1、**不能拿到 Cookie**，也看不到 Cookie 的内容，仅仅是 **冒用**

    2、向服务器提交操作，但是不直接窃取数据，对于 **服务器返回的结果**，由于浏览器同源策略的限制，**攻击者也无法进行解析**

    3、攻击一般发起在 **第三方网站**，而不是被攻击的网站；被攻击的网站无法防止攻击发生

-   【步骤】

    1、用户登录受信任网站 A，并在本地生成 Cookie

    2、在 不登出 A 的情况下，访问危险网站 B

-   【实现方式】

    1、打开黑客的站点后 自动发起 Get/POST 请求

    2、引诱用户点击黑客站点上的链接

-   【案例】

    跨站请求可以用各种方式：图片 URL、超链接、CORS（跨域资源共享）、Form 提交等等；

    受害者登录 a.com，并保留了登录凭证（Cookie）–> 攻击者引诱受害者访问了 b.com –> b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带 a.com 的 Cookie –> a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求 –> a.com 以受害者的名义执行了 act=xx –>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。

![image-20210507113716466](https://codingwithalice.github.io/img/assets_2019/image-20210507113716466.png)

##### 跨站请求伪造 CSRF 防范措施

|                                                       方式                                                       |                                                                                                                                                                                                                             解析                                                                                                                                                                                                                              |
| :--------------------------------------------------------------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|                                                验证码 【体验差】                                                 |                                                                                                                                                                        【优点：最简洁而有效的防御方法 —辅助手段，不能给所有操作加验证码】 强制用户必须与应用进行交互，才能完成最终请求                                                                                                                                                                        |
|                                同源验证 `Referer Check`，HTTP 请求头中的一个字段                                 |                                                                                 【Referer 记录了该 HTTP 请求的来源地址】![image-20210507113804487](https://codingwithalice.github.io/img/assets_2019/image-20210507113804487.png) 服务端通过 Referer 可以检查请求 **是否来自合法的源**：`if (req.headers.referer !== 'http://www.c.com/') { res.write('csrf 攻击’); return;}`                                                                                 |
| Cookie 的 `SameSite` 属性 （在 **HTTP 响应头**中，通过 `set-cookie` 字段设置 Cookie 时，可以带上 SameSite 选项） |                                                                                                                                                                              禁止 Cookie 的发送 如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服务器                                                                                                                                                                              |
|                                           添加 token 验证 【工作量大】                                           |                                                                                                        【关键在于 在请求中放入攻击者所不能伪造的信息，并且不存储于 Cookie 之中】服务器生成一个 Token，并把这个 Token 利用算法加密，加密后的字符串植入到页面 session 中。在页面加载时，在每个 a 标签和 form 标签中放入 Token 服务器验证 Token 是否正确                                                                                                         |
|                                                 双重 Cookie 验证                                                 | 【优点：无需使用 Session，易于实施，可以在前后端统一拦截校验】 【缺点：Cookie 中增加了额外的字段，如果有 XSS 攻击，该防御失效，使用该方案时确保整站 HTTPS 的方式】 利用 CSRF 攻击不能获取到用户 Cookie 的特点，我们可以要求请求携带一个 Cookie 中的值。在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串。在前端向后端发起请求时，取出 Cookie，并添加到 URL 的参数中。后端接口验证 Cookie 中的字段与 URL 参数中的字段是否一致，不一致则拒绝。 |

[懒加载和预加载](https://juejin.cn/post/6844903614138286094)

## 6. 防抖跟节流的区别

相同点：

-   都可以通过使用 setTimeout 来实现
-   目的都是通过降低回调执行频率来节省计算资源

不同点：

-   防抖是在一段连续操作结束后，处理回调，利用 clearTimeout 和 setTimeout 实现。节流是在一段连续操作中，每一段时间只执行一次，频率较高的时间中使用来提高性能
-   防抖关注一定时间连续触发的事件，只在最后一次执行，而节流一段时间内只执行一次。

## 7. 什么是浏览器的事件循环机制

### 微任务、宏任务分别有哪些方法

常见的微任务有：

-   Promise.then
-   MutaionObserver
-   Object.observe（已废弃；Proxy 对象替代）
-   process.nextTick（Node.js）

常见宏任务：

-   setTimeout
-   ajax
-   dom 事件
-   setImmediate(Node 环境)
-   requestAnimationFrame

## 8. umi 和 nextjs 的差异有哪些

Umi 和 Next.js 是两种不同的框架，它们都是用于开发 React 应用程序的。

Umi 是一个以路由为中心的框架，支持快速构建组件、页面和路由。它具有易于扩展的插件体系结构，支持在生产环境中进行代码切割，并且拥有内置的打包和部署工具。

Next.js 是一个服务器端渲染 (SSR) 的框架，提供了方便的页面导航和强大的 SEO 解决方案。它也支持代码切割，并且可以很容易地部署到云平台上，如 Vercel。

总的来说，Umi 和 Next.js 都是优秀的框架，具体使用哪一个取决于您的特定需求和项目要求。

## 9. 有参与前期项目的搭建吗？

## 10. 什么是 ssr？和客户端渲染有什么区别

### 两者本质的区别是什么？

客户端渲染和服务器端渲染的最重要的区别就是**究竟是谁来完成 html 文件的完整拼接，** 如果是在服务器端完成的，然后返回给客户端，就是服务器端渲染，而如果是前端做了更多的工作完成了 html 的拼接，则就是客户端渲染。

### 服务器端渲染的优缺点是怎样的？

#### 优点：

1. **前端耗时少**：因为后端拼接完了 html，浏览器只需要直接渲染出来。用户看到页面的速度快。
2. **有利于 SEO**：因为在后端有完整的 html 页面，所以爬虫更容易爬取获得信息，更有利于 seo。
3. **无需占用客户端资源**：即解析模板的工作完全交由后端来做，客户端只要解析标准的 html 页面即可，这样对于客户端的资源占用更少，尤其是移动端，也可以更省电。
4. **后端生成静态化文件**：即生成缓存片段，这样就可以减少数据库查询浪费的时间了，且对于数据变化不大的页面非常高效 。

**缺点：**

1. **不利于前后端分离，开发效率低。** 使用服务器端渲染，则无法进行分工合作，则对于前端复杂度高的项目，不利于项目高效开发。另外，如果是服务器端渲染，则**前端一般就是写一个静态 html 文件**，然后**后端再修改为模板**，这样是非常低效的，并且还常常需要前后端共同完成修改的动作； **或者是前端直接完成 html 模板，然后交由后端**。另外，如果后端改了模板，前端还需要根据改动的模板再调节 css，这样使得前后端联调的时间增加。
2. **占用服务器端资源**。即服务器端完成 html 模板的解析，如果请求较多，会对服务器造成一定的访问压力。而如果使用前端渲染，就是把这些解析的压力分摊了前端，而这里确实完全交给了一个服务器。

适用场景：
强交互、注重 SEO 的页面，比如购物网站

### 客户端渲染的优缺点是怎样的？

#### 优点：　　

1. **前后端分离**。前端专注于前端 UI，后端专注于 api 开发，且前端有更多的选择性，而不需要遵循后端特定的模板。
2. **体验更好**。比如，我们将网站做成 SPA 或者部分内容做成 SPA，这样，尤其是移动端，可以使体验更接近于原生 app。

#### 缺点：

1. **前端响应较慢**。如果是客户端渲染，前端还要进行拼接字符串的过程，需要耗费额外的时间，不如服务器端渲染速度快。
2. **不利于 SEO**。目前比如百度、谷歌的爬虫对于 SPA 都是不认的，只是记录了一个页面，所以 SEO 很差。因为服务器端可能没有保存完整的 html，而是前端通过 js 进行 dom 的拼接，那么爬虫无法爬取信息。 除非搜索引擎的 seo 可以增加对于 JavaScript 的爬取能力，这才能保证 seo。

适用场景：
强交互、不注重 SEO 的页面，比如管理类的项目。

### 使用服务器端渲染还是客户端渲染？

比如企业级网站，主要功能是**展示**而**没有复杂的交互**，并且需要**良好的 SEO**，则这时我们就需要使用服务器端渲染；而类似后台管理页面，交互性比较强，不需要 seo 的考虑，那么就可以使用客户端渲染。

另外，具体使用何种渲染方法并不是绝对的，比如现在一些网站采用了**首屏服务器端渲染**，即对于用户最开始打开的那个页面采用的是服务器端渲染，这样就保证了渲染速度，而其他的页面采用客户端渲染，这样就完成了前后端分离。

## 11. React 写代码的时候有些推荐的写法？哪些是不推荐的？函数组件的最佳实践的，关于编码的内容？一般写组件的时候推荐怎么写？不推荐怎么写？最佳实践

比如：

1. 子组件没有从父组件传入的 props 或者传入的 props 仅仅为简单数值类型使用 memo 即可。
2. 子组件有从父组件传来的方法时，在使用 memo 的同时，使用 useCallback 包裹该方法，传入方法需要更新的依赖值。
3. 子组件有从父组件传来的对象和数组等值时，在使用 memo 的同时，使用 useMemo 以方法形式返回该对象，传入需要更新的依赖值。

https://juejin.cn/post/7208716321123303483

https://www.freecodecamp.org/chinese/news/best-practices-for-react/#tips-to-help-you-write-better-react-code-the-cherries-on-top

### 1.避免在循环或嵌套函数中使用 Hooks

在 React Hooks 中，应该确保在组件最顶层使用，而不是在循环、条件语句或嵌套函数中使用。这是因为 Hooks 需要遵循 React 的渲染顺序，以便正确更新组件。

### 2.命名约定

在命名 Hooks 时，需要遵循 React 官方提供的约定。例如，useState、useEffect 和 useRef 等都是 React Hooks 中的常用 Hook。

### 3.使用 useEffect 来处理生命周期

在函数式组件中，没有 componentDidMount 和 componentWillUnmount 等生命周期方法。为了处理这些生命周期，我们可以使用 useEffect Hook。useEffect 可以在组件挂载、更新和卸载时执行一些操作，例如发送网络请求或订阅某个事件源。

### 4.使用 useMemo 和 useCallback 来优化效率

当组件需要计算大量数据或处理复杂的逻辑时，使用 useMemo 和 useCallback 可以有效地提高性能。useMemo 可以缓存函数的计算结果，而 useCallback 可以将函数缓存以减少重复渲染。

### 5.使用自定义 Hooks 来复用逻辑

自定义 Hooks 可以让我们将一些常用的逻辑封装到一个函数中，并且可以在多个组件中重复使用。例如，一个名为 useFetch 的自定义 Hook 可以用于发送网络请求并返回数据。

### 6.如何使用 React Hooks

下面我将演示如何使用 React Hooks，并做出相应的解析。

首先，我们来创建一个简单的计数器组件，该组件使用 useState Hook 来管理状态：

```js
js
复制代码import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  const handleIncrement = () => setCount(count + 1);
  const handleDecrement = () => setCount(count - 1);

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={handleIncrement}>Increment</button>
      <button onClick={handleDecrement}>Decrement</button>
    </div>
  );
}

export default Counter;
```

在上面的代码中，我们使用 useState Hook 来定义一个名为 count 的状态，并使用 setCount 函数来更新该状态。useState Hook 的返回值是一个数组，第一个值是状态的初始值，第二个值是用于更新状态的函数。当我们调用 setCount 函数时，React 会重新渲染组件并更新状态。在该组件中，我们定义了两个操作 count 状态的函数，handleIncrement 和 handleDecrement，分别可以用于增加和减少计数器。

接下来，让我们来创建一个使用 useEffect Hook 的组件，该组件会在组件挂载时订阅某个事件源，并在组件卸载时取消订阅：

```js
js
复制代码import React, { useState, useEffect } from 'react';

function EventSubscriber() {
  const [eventData, setEventData] = useState(null);

  useEffect(() => {
    const subscription = eventSource.subscribe((data) => {
      setEventData(data);
    });

    return () => {
      subscription.unsubscribe();
    };
  }, []);

  return (
    <div>
      <h1>Event data: {eventData}</h1>
    </div>
  );
}

export default EventSubscriber;
```

在上面的代码中，我们使用 useEffect Hook 来订阅某个事件源。我们通过传递一个空数组作为 useEffect 的第二个参数来确保 useEffect 只在组件挂载时执行一次。在订阅事件源时，我们返回一个函数来取消订阅，以确保在组件卸载时取消订阅。

最后，让我们来创建一个使用 useMemo 和 useCallback Hooks 的组件，该组件会计算出斐波那契数列：

```js
js
复制代码import React, { useMemo, useCallback } from 'react';

function Fibonacci() {
  const calculateFibonacci = useCallback((n) => {
    if (n <= 1) {
      return 1;
    }
    return calculateFibonacci(n - 1) + calculateFibonacci(n - 2);
  }, []);

  const fibonacciNumber = useMemo(() => calculateFibonacci(10), [calculateFibonacci]);

  return (
    <div>
      <h1>Fibonacci number: {fibonacciNumber}</h1>
    </div>
  );
}

export default Fibonacci;
```

在上面的代码中，我们使用 useCallback Hook 来缓存 calculateFibonacci 函数，以便在组件重渲染时不会重复计算斐波那契数列。我们还使用 useMemo Hook 来缓存计算结果，以便在组件重渲染时不会重复计算。

### 7.总结

综上所述，React Hooks 可以提高 React 应用程序的可维护性和性能。在使用 Hooks 时需要遵循上述最佳实践，确保代码的正确性和可读性。

## 12. 项目难点

被问到项目亮点、难点、遇到的问题、解决思路

https://blog.csdn.net/gaoyu007/article/details/117200172

商品同步的问题

购物车
有加购的商品列表
然后它下面会展示一些相关联的商品信息
下面的商品也是可以加购的，但是加购之后需要同步到上面的商品列表

解决的方式

维护页面

客户希望系统维护期间，网站可以展示维护页面，前期的要求是输入密码可正常访问

分页算不算？

正常分页的话是这样的，接口请求时传递当前页索引、每页数量、总数。
但是因为 RTI 的接口所给的数据没有总数，所以分页的时候需要前端做一些处理

将 page（当前页索引）记录到 url 上，点击分页按钮时，将页数据信息通过接口请求给后端
web 很好实现

### wap 端使用的是上下滑动分页

所以需要监听滑动事件从而控制接口请求，另外就是接口请求的参数处理和拿到数据以后的处理

实现：

#### 1. 监听滑动事件从而控制接口请求

可能的方法如下：
使用 scrollTop、clientHeight 等属性方法来获取想要的滚动数据等，即使用传统的滚动事件监听

```js
window.addEventListener('scroll', function () {
    // 获取滚动条滚动的距离
    var scrollTop =
        document.documentElement.scrollTop || document.body.scrollTop;
    // 获取整个页面的高度
    var scrollHeight =
        document.documentElement.scrollHeight || document.body.scrollHeight;
    // 获取视口的高度
    var clientHeight =
        document.documentElement.clientHeight || document.body.clientHeight;
    // 计算距离底部的高度
    var scrollDistance = scrollHeight - scrollTop - clientHeight;
    // 如果距离底部的高度小于某个值（比如100），可以认为是滚动到底部了
    if (scrollDistance <= 100) {
        // 触发滚动到底部的逻辑
        console.log('页面滚动到底部了！');
        // 在这里可以调用加载更多内容、显示加载提示等逻辑
    }
});
```

项目中使用的是 IntersectionObserver

```js
// 创建一个观察器实例
const observer = new IntersectionObserver(
    (entries, observer) => {
        entries.forEach((entry) => {
            // 检查目标元素是否进入视口
            if (entry.isIntersecting) {
                // 触发滚动到底部的逻辑
                console.log('页面滚动到底部了！');
                // 加载更多内容或者执行其他操作
                // ...

                // 如果不再需要观察，可以停止观察
                observer.unobserve(entry.target);
            }
        });
    },
    {
        // 配置选项
        threshold: 1.0, // 当目标元素的可见比例达到100%时，触发回调函数
        root: null, // 使用视口作为根
        rootMargin: '0px', // 根边界
    }
);

// 获取页面底部的元素，通常是一个占位符或者加载更多的按钮
const bottomElement = document.querySelector('#bottom-element');

// 观察页面底部的元素
observer.observe(bottomElement);
```

比如一页展示 5 条数据，在数据展示的末尾处插入一个 id 为 BOTTOM_ID 的 div，用作标记末尾位置。
获取 BOTTOM_ID 元素，然后创建一个 IntersectionObserver 实例，并配置监听的对象和相关属性，
比如 threshold 为 0.1，表示当目标元素的可见比例（相交比例）达到 10%时，就触发回调函数。

```jsx
useEffect(() => {
    let observer;
    const ref = document.getElementById(BOTTOM_ID);
    if (isNext) {
        observer = new IntersectionObserver(handleScroll, {
            threshold: 0.1,
        });
        if (ref) {
            observer.observe(ref);
        }
    }
    return () => {
        if (isNext && ref) {
            observer.unobserve(ref);
        }
        mountedRef.current = true;
    };
}, []);
```

回调函数有一个参数，是数组，每一个成员都是 IntersectionObserverEntry 对象，IntersectionObserverEntry 对象有几个属性，
其中 isIntersecting 的值是一个布尔值，指示目标元素是否已转换为相交状态 ( true) 还是脱离相交状态 ( false)。
如果处于相交状态就触发后续代码操作，修改 router 的 page 的值

useEffect 依赖了 router，当 router 修改的时候会重新获取数据

```jsx
const handleScroll = useCallback(
    throttle((event) => {
        const entry = event[0];
        if (entry?.isIntersecting && !loadingRef.current && !isAllRef.current) {
            router.replace(
                {
                    pathname: router.asPath.split('?')[0],
                    query: handleUrlParams({
                        ...routerRef.current,
                        page: currentRef.current + 1,
                    }),
                },
                null,
                { scroll: false, shallow: true }
            );
        }
    }, 400),
    []
);
```

补充知识点：
[IntersectionObserver API 使用教程](https://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html)

```js
var io = new IntersectionObserver(callback, option);
```

IntersectionObserver 是浏览器原生提供的构造函数，接受两个参数：callback 是可见性变化时的回调函数，option 是配置对象（该参数可选）

构造函数的返回值是一个观察器实例。实例的 observe 方法可以指定观察哪个 DOM 节点。

```js
// 开始观察
io.observe(document.getElementById('example'));

// 停止观察
io.unobserve(element);

// 关闭观察器
io.disconnect();
```

如果要观察多个节点，就要多次调用这个方法。

```js
io.observe(elementA);
io.observe(elementB);
```

该 IntersectionObserverEntry 接口的只读 **isIntersecting** 属性是一个布尔值，表示 true 目标元素是否与相交观察器的根相交。如果是 true，则 IntersectionObserverEntry 描述了到相交状态的转变；如果是 false，那么您知道过渡是从相交到不相交。

#### 2. 接口请求的参数处理和拿到数据以后的处理

接口参数处理：
确定当前页索引
如果购物车列表 shopCarList 为空且页码 val 大于 1，说明刷新了页面，购物车的做法是重置 page 为 1，后续就不需要了。直接获取第一页的数据就行。

接口请求到数据后：
修改某些属性，比如 loading 为 false；
如果拿到的 list 长度为 0，表示后续没有数据可以请求了，isAll 修改为 true
否则就处理数据，保存数据。
保存数据的时候需要判断，当前 page 为 1，直接 set 数据，否则，将新数据和旧数据合并

```js
const getProducts = () => {
    const val = parseInt(page);
    if (shopCarList.length == 0 && val > 1) {
        const url = {
            pathname: router.pathname,
            query: { ...router.query, page: 1 },
        };
        router.replace(url);
        return;
    }
    const current = typeof val === 'number' && !isNaN(val) && val > 0 ? val : 1;
    currentRef.current = current;
    loadingRef.current = true;
    const pageNo = shopCarList.length == 0 && val != '1' ? 1 : current;

    setLoading(true);
    request({ skip: pageNo - 1, take: PGAE_SIZE })
        .then(({ data = {} }) => {
            const list = data.shopCarList || [];
            if (!mountedRef.current) {
                routerRef.current = router.query;
                loadingRef.current = false;
                const isAll = list.length == 0;
                isAllRef.current = isAll;
                currentRef.current =
                    current == 1 ? 1 : isAll ? currentRef.current : current;
                list.map((item) => {
                    /* 商品数据处理 */
                });
                if (current == 1) {
                    setShopCarList(list);
                    setOtherShopCarList(data.otherShopCarList || []);
                } else if (!isAll) {
                    setShopCarList((v) => [...v, ...list]);
                }
                setLoading(false);
            }
        })
        .catch((err) => {
            !mountedRef.current && setLoading(false);
        });
};
```

## 13. 面试官：有什么想问我的？
