# 3 月 6 号面试题

## 1. 有对项目进行哪些配置吗

### 1. 环境配置

根据项目运行的环境，配置不同的环境变量。例如开发环境、测试环境和生产环境可能需要请求不同的 API 地址、token 等；

在 ops 项目中：

项目的开发、测试环境和生产环境所请求的 API 是不一致的。这个时候我们在 utils 文件中会配置 env 的值，以及其相对的 api 地址。切换不同环境时，修改 env 的值以确保使用正确的 api 地址。

```js
let env = 'prod';
let apiHost = '';
let poHost = '';
if (env == 'test') {
    apiHost = 'https://testapi.grosiraja.com/cms/';
    poHost = 'https://testapi.grosiraja.com/supply/';
}
if (env == 'dev') {
    apiHost = 'https://devapi.grosiraja.com/cms/';
    poHost = 'https://devapi.grosiraja.com/supply/';
}
if (env == 'prod') {
    apiHost = 'https://api.grosiraja.com/cms/';
    poHost = 'https://api.grosiraja.com/supply/';
}
export { apiHost, poHost };
```

web 和 wap 项目也是如此

```js
let env = 'gro';
let ipUrl = '';
let prodIpUrl = '';

if (env == 'gro') {
    ipUrl = 'https://api.gor.grosiraja.com'; // gro
    prodIpUrl = 'https://api.gor.grosiraja.com';
}
if (env == 'dev') {
    ipUrl = 'https://dev-api.gocart.ph'; // dev
    prodIpUrl = 'http://10.60.13.197:8000';
}
if (env == 'staging') {
    ipUrl = 'https://staging-api.gocart.ph'; //staging
    prodIpUrl = 'http://10.60.13.198:8000'; // prod http
}
if (env == 'master') {
    ipUrl = 'https://pre-prod-api.gocart.ph'; // prod https
    prodIpUrl = 'http://10.60.14.51:8000'; // prod http
}
```

### 2. 依赖环境

使用包管理器（如 npm、Maven、Gradle 等）来管理项目的依赖。这些依赖可能包括库、框架、插件等。

web 项目中：

-   .babelrc 文件

文件相关配置

```json
{
    "presets": ["next/babel"], //Next.js的总配置文件，相当于继承了它本身的所有配置
    "plugins": [
        //增加新的插件，这个插件就是让antd可以按需引入，包括CSS
        [
            "import",
            {
                "libraryName": "antd",
                "libraryDirectory": "lib"
            },
            "antd"
        ]
    ]
}
```

-   .gitignore 文件

用于忽略不需要被（git）跟踪的目录和文件

```shell
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules

# testing
/coverage

# next.js
/.next/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env.local
.env.development.local
.env.test.local
.env.production.local

# vercel
.vercel

.history
```

扩展：[一文详解.gitignore 与.gitkeep 的作用与使用规则](https://juejin.cn/post/7080131568215261192)

-   next.config.js

```js
const withLess = require('next-with-less');
const withVideos = require('next-videos'); // 加载视频 video
const CopyPlugin = require('copy-webpack-plugin');

module.exports = withLess(
    withVideos({
        // reactStrictMode: true,
        // productionBrowserSourceMaps: true,
        lessLoaderOptions: {
            /* ... */
            lessOptions: {
                /* ... */
                modifyVars: {
                    'primary-color': '#21BC88',
                    'primary-backgroundcolor':
                        'linear-gradient(265.12deg, #38EF7D -118.43%, #11998E 72.97%)',
                    /* ... */
                },
            },
        },
        experimental: {
            outputStandalone: true,
        },
        images: {
            domains: [
                'files.rrhiapps.ph',
                'firebasestorage.googleapis.com',
                'dummyimage.com',
                'uploads.gocart.ph',
            ],
        },
        webpack: (config, options) => {
            // Important: return the modified config
            config.plugins.push(
                new CopyPlugin({
                    patterns: [
                        {
                            from: './docker/healthcheck.js',
                            to: './',
                        },
                    ],
                })
            );

            // Important: return the modified config
            return config;
        },
        // env: {
        //   // Add any logic you want here, returning `true` to enable password protect.
        //   PASSWORD_PROTECT: true,
        // },
        // async redirects() {
        //   return [
        //     {
        //       source: '/',
        //       destination: '/mycart',
        //       permanent: true,
        //     },
        //   ]
        // },
    })
);
```

### 3. 代码规范

配置代码规范检查工具（如 ESLint、TSLint、Checkstyle 等），以确保代码风格一致、符合规范，并减少潜在的错误。

比如统一代码缩进 2 个或 4 个字符。修改 vscode 的 Tab Size 的值

.eslintrc.json

```json
{
    "extends": "next/core-web-vitals"
}
```

### 4. 构建和部署

配置构建工具（如 webpack、gradle builddeng）来自动化构建过程，包括代码编译、打包、测试等。同时，配置部署工具（如 Docker、Kubernetesdeng）以自动化部署应用到服务器。

比如 ops 项目：
这是一个已有的项目，主要是进行项目维护

使用的是 umi 框架搭建

-   因为项目代码量大，所以会遇到打包速度慢的情况
    如果遇到编译慢、增量编译慢、内存爆、OOM 等问题，可以尝试以下方法。

所以进行在 config 目录下的 config.js 文件里配置了

```js
nodeModulesTransform: {
  type: 'none',
  exclude: [],
}
```

这也是官方提供的一个解决方案

-   当遇到打包占用内存太大，电脑可用内存不足，打包失败

我们进行打包的时候，项目过大时，可能会遇到（webpack）打包过程中占用的内存堆栈超出了 node.js 中采用 V8 引擎对内存的限制，V8 引擎对内存的使用的默认大小限制是 1536 (1.5 GiB)，那我们就可以通过修改这个内存限制来解决。

所以对 package.json 文件的 build 命令进行一个修改：

```js
// 修改前
"build": "umi build",
// 修改后
"build": "cross-env NODE_OPTIONS=--max-old-space-size=4096 umi build"
```

配置部署工具

```dockerfile
# Install dependencies only when needed
FROM node:16-alpine AS deps
# Check https://github.com/nodejs/docker-node/tree/b4117f9333da4138b03a546ec926ef50a31506c3#nodealpine to understand why libc6-compat might be needed.
RUN apk add --no-cache libc6-compat
WORKDIR /app
COPY package.json yarn.lock ./
RUN yarn install --frozen-lockfile

# If using npm with a `package-lock.json` comment out above and use below instead
# COPY ./package.json ./package-lock.json ./
# RUN npm ci

# Rebuild the source code only when needed
FROM node:16-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Next.js collects completely anonymous telemetry data about general usage.
# Learn more here: https://nextjs.org/telemetry
# Uncomment the following line in case you want to disable telemetry during the build.
# ENV NEXT_TELEMETRY_DISABLED 1

RUN yarn build
# RUN npm run build

# Production image, copy all the files and run next
FROM node:16-alpine AS runner
WORKDIR /app

ENV NODE_ENV production
# Uncomment the following line in case you want to disable telemetry during runtime.
# ENV NEXT_TELEMETRY_DISABLED 1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# You only need to copy next.config.js if you are NOT using the default configuration
# COPY --from=builder /app/next.config.js ./
COPY --from=builder /app/public ./public
COPY --from=builder /app/package.json ./package.json

# Automatically leverage output traces to reduce image size
# https://nextjs.org/docs/advanced-features/output-file-tracing
COPY --from=builder --chown=nextjs:nodejs /app/.next/healthcheck.js ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000

CMD ["node", "server.js"]
```

docker 目录

deploy.sh

```sh
#!/bin/bash

DOCKER_USERNAME=$1
DOCKER_PASSWORD=$2
TAG=$3
BASEDIR=$4
APPNAME=$5
PORT=$6
REPLICAS=$7
PARALLELISM=$8

docker_install()
{
	echo "检查Docker......"
	docker -v
    if [ $? -eq  0 ]; then
        echo "检查到Docker已安装!"
    else
    	echo "安装Docker环境..."
        curl -sSL https://get.daocloud.io/docker | sh
        echo "安装Docker环境...安装完成!"
        echo "启动Docker..."
        systemctl start docker
        echo "启动Docker...启动成功!"
    fi
    # 创建公用网络==bridge模式
    #docker network create share_network
}

docker_install

echo "登录Docker镜像仓库..."
echo $DOCKER_PASSWORD | docker login --username $DOCKER_USERNAME --password-stdin registry.cn-beijing.aliyuncs.com
echo "登录Docker镜像仓库...登录成功!"

# docker swarm init

echo "无中断部署服务..."
TAG=$DATETIME PORT=$PORT REPLICAS=$REPLICAS PARALLELISM=$PARALLELISM docker stack deploy --with-registry-auth -c $BASEDIR/docker-compose.yml $APPNAME
echo "无中断部署服务...部署成功!"
```

docker-compose.yml

```yml
version: '3.7'

services:
    nodejs:
        image: registry.cn-beijing.aliyuncs.com/gocart/web:${TAG}
        ports:
            - '${PORT}:3000'
        command: node server.js
        deploy:
            replicas: ${REPLICAS}
            update_config:
                parallelism: ${PARALLELISM}
                order: start-first
                failure_action: rollback
                delay: 10s
            rollback_config:
                parallelism: 0
                order: stop-first
            restart_policy:
                condition: any
                delay: 5s
                max_attempts: 3
                window: 120s
        healthcheck:
            test: ['CMD', 'node', 'healthcheck.js']
```

healthcheck.js

```js
const http = require('http');
const options = {
    host: '0.0.0.0',
    port: 3000,
    timeout: 2000,
};

const healthCheck = http.request(options, (res) => {
    console.log(`HEALTHCHECK STATUS: ${res.statusCode}`);
    if (res.statusCode == 200) {
        process.exit(0);
    } else {
        process.exit(1);
    }
});

healthCheck.on('error', function (err) {
    console.error('ERROR');
    process.exit(1);
});

healthCheck.end();
```

.env

```js
TAG=1.0.1
PORT=3001
REPLICAS=2
PARALLELISM=3001
```

### 5. 安全性配置

配置项目的安全策略，如身份验证、授权、加密等，以确保项目的安全性

比如 ops

[前端利用 jsencrypt.js 进行 RSA 加密](https://segmentfault.com/a/1190000023404169)

对于请求数据有进行 RSA 非对称加密，使用的是 jsencrypt 库

```js
var encryptor = new JSEncrypt(); // 创建加密对象实例
//之前ssl生成的公钥，复制的时候要小心不要有空格
var pubKey =
    '-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC1QQRl0HlrVv6kGqhgonD6A9SU6ZJpnEN+Q0blT/ue6Ndt97WRfxtSAs0QoquTreaDtfC4RRX4o+CU6BTuHLUm+eSvxZS9TzbwoYZq7ObbQAZAY+SYDgAA5PHf1wNN20dGMFFgVS/y0ZWvv1UNa2laEz0I8Vmr5ZlzIn88GkmSiQIDAQAB-----END PUBLIC KEY-----';
encryptor.setPublicKey(pubKey); //设置公钥
var rsaPassWord = encryptor.encrypt('要加密的内容'); // 对内容进行加密
```

ops 的实现

公钥会根据 env 的值来进行调整，不同的环境使用不同的公钥

```js
SEncrypt.prototype.encryptLong = function (string) {
    var k = this.getKey();
    try {
        var ct = '';
        //RSA每次加密117bytes，需要辅助方法判断字符串截取位置
        //1.获取字符串截取点
        var bytes = new Array();
        bytes.push(0);
        var byteNo = 0;
        var len, c;
        len = string.length;
        var temp = 0;
        for (var i = 0; i < len; i++) {
            c = string.charCodeAt(i);
            if (c >= 0x010000 && c <= 0x10ffff) {
                //特殊字符，如Ř，Ţ
                byteNo += 4;
            } else if (c >= 0x000800 && c <= 0x00ffff) {
                //中文以及标点符号
                byteNo += 3;
            } else if (c >= 0x000080 && c <= 0x0007ff) {
                //特殊字符，如È，Ò
                byteNo += 2;
            } else {
                // 英文以及标点符号
                byteNo += 1;
            }
            if (byteNo % 117 >= 114 || byteNo % 117 == 0) {
                if (byteNo - temp >= 114) {
                    bytes.push(i);
                    temp = byteNo;
                }
            }
        }
        //2.截取字符串并分段加密
        if (bytes.length > 1) {
            for (var i = 0; i < bytes.length - 1; i++) {
                var str;
                if (i == 0) {
                    str = string.substring(0, bytes[i + 1] + 1);
                } else {
                    str = string.substring(bytes[i] + 1, bytes[i + 1] + 1);
                }
                var t1 = k.encrypt(str);
                ct += t1;
            }
            if (bytes[bytes.length - 1] != string.length - 1) {
                var lastStr = string.substring(bytes[bytes.length - 1] + 1);
                ct += k.encrypt(lastStr);
            }
            return ct;
        }
        var t = k.encrypt(string);
        // var y = hex2b64(t);
        return t;
    } catch (ex) {
        return false;
    }
};
const encrypt = new JSEncrypt();
if (env == 'test') {
    encrypt.setPublicKey(
        '-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz5sQUPqadstAXXEbXe+kKaRyxvuAQFUXLRzncCFG5Z5nPEuIW5UqnquUW5H08lkg+HMm7qipDRKveU3nWLV325sYib7CRAGMt1knsoOYi6d6OX9yvb27Fxm/lzDnJD0+pRUZKIz+sq4cC5fTovR9kqY3AO6wYUoAZw7xmYCMnMQF43Nimrn01/P8JNj9YgdaYZq6Jn6KUqjF8kRM8+Q2HdcwXoL9WMPILqbf+fa3V3tyXK2DMarLOLvmOmRLS9lIIvTZ6tH09OoTKl6Pg6FMyd5uvfphF407CM5CsSW3pNckw8Aernp9O3+s6Wi4FnxbrzSfhYCPlm0k01VEmzsdPwIDAQAB-----END PUBLIC KEY-----'
    );
}

if (env == 'dev') {
    encrypt.setPublicKey(
        '-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnDk/VvHj+rB83SL3vYxFasr7FQLu7ZvPhQhCv5GJM0JoQeTQ+Uyxs3QZZD6roOiXl74hcr/2WZz5wH5UzPTQ4gi/xdmDqfBVZNiPyMoCwQag+BZ3hKoasV6csy6GGf9hxu4oM/qNlcH3a4+cRh8JoGIYRmBDHVNBcUz6g/q6HB9jd4DptFCdGYHLA+fi2tyZby/+kf5UXuevVt+65CRcSsvfF88MpdDx+QTkC879UZ16B0H++0uB98LShIH1Kt1kSESaG9c3bUp3o0vJHbyK05Bu/UfspD0qdk8JsJkI2uxiVH6l3NHfmQor5oMLQAcnJZDcrbtQxYiymh9pfr1DeQIDAQAB-----END PUBLIC KEY-----'
    );
}

if (env == 'prod') {
    encrypt.setPublicKey(
        '-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAkQEICxoRgjffbzsXAGhvdlR4D+h+cuqwNyFeVKi9ZVJqLiq+qKTIsvwwopqMvoJ/+gHu0Qyq11Di7bl7COvrr0BLecunJsqEfhc45A7aUvb+mwHRh4/5pgRVci2TvUQEkYonkfe9eKaogESSHt7ET1RsJLA2nUGapZqcVsOLfqqf3556oi4BpqmmvOgR1Pz3DZ9jm46gVoormASNkizwkkfvnKjaEt1hFVQtus5yfKzPL7eSBzwl7naAW9l6e+sN9IFGHpOWZoQhXzG6vRipL5uvYoyvh3oHmqShZdVTnuNG1CbQTNB+9BiElUqX8kE+VOEK3cazden3MzP+t6u/FwIDAQAB-----END PUBLIC KEY-----'
    );
}
```

## 2. React 里面常用的 Hooks

1. useState

状态是变化的数据，是组件甚至前端应用的核心。useState 有传入值和函数两种参数，返回的 setState 也有传入值和函数两种参数。

```js
// 传入值
const [state, setState] = useState(0);
// 传入函数
const [num, setNum] = useState(() => {
    let a = 1,
        b = 2;
    return a + b;
});

setState(1);
setNum((state) => state + 1); // 函数的参数是上一次的 state
```

2. useEffect

副作用 effect 函数是在渲染之外额外执行的一些逻辑。它是根据第二个参数的依赖数组是否变化来决定是否执行 effect，可以返回一个清理函数，会在组件卸载前执行或每次使用更改的依赖性重新渲染之前运行。
执行时机：在渲染结束之后

```js
useEffect(() => {
    let timer = setTimeout(() => {
        console.log(num);
    }, 5000);
    return () => {
        // 清理函数
        clearTimeout(timer);
    };
}, [num]); // 如果不传第二个参数时，每次都会执行；传递第二个参数时，第二个参数有变化时执行
```

3. useLayoutEffect

和 useEffect 差不多，但是 useEffect 的 effect 函数是异步执行的，所以可能中间有次渲染会闪屏。而 useLayoutEffect 是同步执行的，所以不会闪屏，但如果计算量大可能会导致掉帧，阻塞渲染。所以，仅当在浏览器渲染之前运行效果至关重要时才需要此功能，例如：在用户看到工具提示之前测量和定位工具提示。（只有在关键时刻需要在用户看到之前运行你的 Effect 时才需要使用它，例如，在显示提示工具提示之前测量和定位位置。）

4. useInsertionEffect

回调函数会在 commit 阶段的 Mutation 子阶段同步执行，与 useLayoutEffect 的区别在于执行的时候无法访问 DOM 的引用。这个 Hook 是专门为 CSS-in-JS 库插入全局的 style 元素而设计。

5. useReducer

封装一些修改状态的逻辑到 reducer，通过 action 触发。当修改深层对象的时候，创建新对象比较麻烦，可以结合 immer 来解决。

```js

```

6. useRef

可以保存 dom 引用或其他内容，通过`.current`来取，改变它的内容不会触发重新渲染。

7. forwardRef + useImperativeHandle

通过 forwardRef 可以从子组件转发 ref 到父组件。如果想自定义 ref 内容可以使用 useImperativeHandle 来实现。

8. useContext

跨层组件之间传递数据可以使用 Context。用 createContext 创建 context 对象，用 Provider 修改其中的值，函数组件使用 useContext 来取值，类组件使用 Consumer 来取值。

9. memo + useMemo + useCallback

memo 包裹的组件只有在 props 变化的时候才会重新渲染，useMemo、useCallback 可以防止 props 不必要的变化，两者一般是结合使用。不过当用来缓存计算结果等场景的时候，也可以单独使用 useMemo、useCallback。

### 补充提问：说一说 useEffect 和 useLayoutEffect 的区别

在 React 中，用于定义有副作用因变量的 Hook 有：

-   useEffect：回调函数会在 commit 阶段完成后异步执行，所以不会阻塞视图渲染
-   useLayoutEffect：回调函数会在 commit 阶段的 Layout 子阶段同步执行，一般用于执行 DOM 相关的操作

每一个 effect 会与当前 FC 其他的 effect 形成环状链表，连接方式为单向环状链表。
其中 useEffect 工作流程可以分为：

-   声明阶段
-   调度阶段
-   执行阶段

useLayoutEffect 的工作流程可以分为：

-   声明阶段
-   执行阶段

之所以 useEffect 会比 useLayoutEffect 多一个阶段，就是因为 useEffect 的回调函数会在 commit 阶段完成后异步执行，因此需要经历调度阶段。

### 补充提问：项目中有没有用到 redux

## 3. 场景题 - 页面优化

### 前端页面会向后端去获取一些数据，用于列表展示，比如博客列表、菜谱列表，那数据量相对来说是比较大的，所以当接口请求数据较慢的时候，前端可以做哪些优化处理呢？

后端数据请求比较慢的时候，前端可以在体验上做一些优化，毕竟数据层面不是我们可以去掌控的。比如使用 Skeleton 骨架屏、loading、虚拟滚动、分页等。

-   懒加载
    对于非首屏显示的数据，如滚动列表中的项目，可以使用懒加载。这意味着在用户滚动到需要显示数据的区域之前，不会请求数据。这减少了初始加载时的请求量，提高了首屏加载速度。

[长列表加载（懒加载、虚拟列表）](https://juejin.cn/post/7258159278489321531)

-   虚拟滚动

    -   **按需渲染**：在同一时间内，只渲染我们看得见（视口）的 DOM 节点，这样浏览器需要渲染的节点就少了，从而降低渲染时长。
    -   **模拟滚动**：在用户滚动滑轮或滑动屏幕的时候，模拟滚动行为去滚动列表，即根据滚动的位置重新渲染可见的列表元素。

[虚拟滚动](https://juejin.cn/post/6844904183582162957)

-   分页

对于大量数据，不要一次性加载全部，而是将数据分为多个页面，用户可以按需加载。这减轻了服务器的压力，并降低了每次请求的数据量。

3. 数据缓存

对于不经常变更的数据，前端可以使用本地缓存技术（如 localStroage、sessionStorage 或 IndexedDB）来存储之前请求过的数据。当再次需要这些数据时，可以先检查本地缓存，如果数据存在且未过期，则直接使用缓存数据，避免重复请求后端。

4. 请求合并

如果多个请求可以合并为一个，那么应该尽量减少单独的请求次数。例如，当页面需要加载多个资源时，可以合并这些请求为一个请求。

5. 请求优化

优化请求参数，减少不必要的字段或数据，确保请求的数据量尽可能小。此外，可以考虑使用 HTTP/2 或更高版本的协议，利用多路复用、头部压缩等技术来减少传输延迟。

6. 加载动画与占位符

在数据加载过程中，为用户提供加载动画或占位符，使用户知道数据正在加载中，而不是让页面处于空白或停滞状态。

7. 预加载

预加载是一种预测性加载技术，根据用户的操作习惯或页面上下文，提前加载用户可能需要的数据。例如，在滚动列表时，可以提前加载下一页的数据。

8. 延迟加载

对于非核心功能或用户可能不会立即注意到的数据，可以使用延迟加载。即先加载核心数据，然后等待一段时间（如用户滚动到页面底部）后再加载其他数据。

9.服务端渲染或预渲染

对于需要大量数据渲染的页面，可以考虑使用服务端渲染技术。这样，用户在首屏加载时就能看到完整的数据，而不是等待前端请求和渲染。

预渲染则是一种在构建阶段生成静态 HTML 页面的技术，适用于内容不经常变更的场景。

10. 优化后端接口性能

前端优化只是提升用户体验的一部分，同时也需要关注后端接口的性能。确保后端接口响应迅速，数据处理高效，以及数据库查询优化等。

## 跨域是怎么解决

跨域是由于浏览器的同源策略所导致，是发生在页面到服务端请求的过程中。

跨域解决方法：

## 如果想在页面加载的时候发送请求，类组件和函数组件分别写在哪里

**类组件**：

React 中请求通常在 **componentDidMount 生命周期函数**中发送。这个生命周期函数在组件已经挂载到页面上，并且可以操作 DOM 元素时调用。

**函数组件**：

在 useEffect 中发送请求

## 用过 lodash 吗？常用的方法有些？

用过。

常用的方法有：
