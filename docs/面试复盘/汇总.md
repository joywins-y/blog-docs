# 03.04

## 前端判断数据类型

1. **typeof**

    对象（{}）、数组（[]）、null 的结果都是 object

    新数据类型如 Symbol、BigInt，无法识别

2. **instanceof**

    无法判断基本数据类型和 null

3. **Object.prototype.toString.call()**

    语法相对复杂，但是可以区分数组、函数等引用数据类型

4. **Array.isArray()**

    只能判断数组类型，精准判断数组

typeof 和 instanceof 的区别：

返回值类型：typeof 返回一个表示数据类型的字符串，instanceof 返回一个布尔值，表示是否是指定类的实例

判断范围：typeof 相对来说可以判断的类型更多，instanceof 只能用来判断对象类型（也就是两者互补）。

精确性：typeof 对基本数据类型判断比较精确，对于引用类型则无法进一步区分。instanceof 可以准确的判断引用类型。

# 防抖和节流

## 防抖

防抖是指在用户事件被触发 n 秒后再执行回调逻辑，如果在这 n 秒内事件再次被触发，则重新计时。换言之，程序只执行最后一次触发事件，以此来优化性能。

实现代码：

```js
const debounce = (fn, delay) => {
    let timer = null;
    return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => {
            fn(args);
        }, delay);
    };
};
```

## 节流

节流是指当遇到连续用户事件时，以 n 秒为间隔进行阻断，目的是减少同一时间段内连续事件的触发频率，以此来提升性能。

实现代码：

```js
const trottle = (fn, delay) => {
    let timer = null;
    return function (...args) {
        if (timer) return;
        timer = setTimeout(() => {
            fn(args);
            clearTimeout(timer);
            timer = null;
        }, delay);
    };
};
```

# 深拷贝

## JSON.parse(JSON.stringify(obj))

缺点：JSON.stringify() 会丢失部分属性

关于 **key 为 Symbol** 的会忽略掉，值为 **undefined** 的会忽略掉，**NaN** 变成 null，**函数**会忽略掉，**Infinity** 会变成 null

总结来说：

无法复制函数和 undefined；

如果对象中包含循环引用，会抛出错误；

对于包含 Symbol、RegExp 等特殊类型的对象，可能无法正确工作

```js
const obj = {
    [Symbol.for('key1')]: 'a',
    b: undefined,
    c: NaN,
    d: () => {
        return null;
    },
    e: Infinity,
    f: null,
};
console.log(JSON.parse(JSON.stringify(obj))); // {c: null, e: null, f: null}
```

![image-20240305135515117](/Users/fiat_lux/Library/Application Support/typora-user-images/image-20240305135515117.png)

## 使用 js 工具库 lodash

```js
const obj = { a: 1, b: 2, c: 3 };
const newObj = _.cloneDeep(obj);
```

## 递归复制

```js
function deepClone(obj) {
    // 先判断 obj 的数据类型
    if (obj === null) return obj; // obj 为 null
    if (obj instanceof Date) return new Date(obj); // obj 为 Date
    if (obj instanceof RegExp) return new RegExp(obj); // obj 为 RegExp
    if (typeof obj !== 'object') return obj;
    let cloneObj = new obj.constructor();
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            // 实现一个递归拷贝
            cloneObj[key] = deepClone(obj[key]);
        }
    }
    return cloneObj;
}
```

## 扩展：

JSON.stringify(value, replacer, space)

参数一：value 表示要被序列化的对象，接受对象或数组类型

参数二：replacer 用于标记需要序列化的属性，接受数组和函数类型

参数三：space 用于描述序列化后的缩进字符数，用于美化格式

使用场景：

1. localStorage 的存储

​ localStorage 只能存储字符串类型，kv（key，value） 结构

```js
const obj = { a: 1, b: 2, c: 3 };
// 序列化要存储的数据: JSON.stringify(obj)
// 存储
localStorage.setItem('obj', JSON.stringify(obj));
// 取出
localStorage.getItem('obj'); // '{"a":1,"b":2,"c":3}'
// 移除
localStorage.removeItem('obj');
```

2. 对象的深拷贝

    ```js
    const obj = { a: 1, b: 2, c: 3 };
    const objA = obj;
    const objB = JSON.parse(JSON.stringify(obj));
    // 修改
    objA.a = 11;
    console.log(obj); // {a: 11, b: 2, c: 3}
    console.log(objA); // {a: 11, b: 2, c: 3}

    objB.a = 123;
    console.log(obj); // {a: 11, b: 2, c: 3}
    console.log(objB); // {a: 123, b: 2, c: 3}
    ```

3. 删除对象属性

    ```js
    const obj = { a: 1, b: 2, c: 3 };
    const str = JSON.stringify(obj, (key, value) => {
        if (key === 'b') {
            return undefined;
        }
        return value;
    });
    console.log(str); // '{"a":1,"c":3}'
    const objA = JSON.parse(str);
    console.log(objA); // {a: 1, c: 3}
    ```

# 前端跨域

跨域是前端解决的范畴

什么时候会发生跨域

跨域是由于浏览器的同源策略（协议、域名、端口）所导致的，是发生在 页面 到 服务端 请求的过程中

项目中怎么解决这个跨域问题的

1. Nginx 反向代理（可以使用 docker 开镜像）

    例如：server 监听 5000 端口，如果访问路径是 / ，那么代理转发到 3000 端口，然后设置 header 相关属性。如果访问路径是/api，就转发到 4000 端口，同样设置 header 相关属性。这样，通过就解决跨域了。

    ```js
    server {
        listen      5000;
        server_name 127.0.0.1;

        location / {
            proxy_pass http://127.0.0.1:3000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        location /api {
            proxy_pass http://127.0.0.1:4000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
    ```

2. 搭建 BFF 层

```js
// 架设 BFF 层解决跨域问题
const KoaRouter = require('koa-router');
const router = new KoaRouter();
router.post('/api/task', async (ctx, next) => {
    const res = await axios.post('http://127.0.0.1:4000/api/task');
    ctx.body = res.data;
});
app.use(router.routes());
app.use(router.allowedMethods());
```

实际项目中使用什么方法解决还要看项目中使用的相关技术

尽量以最简单快捷的方法

了解后端处理跨域的原理吗

可以使用 nginx，但是我们项目后端是在微服务中处理跨域

# cookie 和 localStorage 的区别

项目中的登录是用的 cookie 还是 localStorage 来保存 token 的？

cookie

用户在浏览器这边进行登录接口请求，服务端收到这个请求之后，在用户名和密码都正确的情况下，服务器在向浏览器返回登录结果的时候，会生成一个 cookie，并且在 Http Response Header 中 Set-Cookie。这样，当浏览器再次请求服务端时，都会同步的带上 cookie，cookie 会附带在每个 Http 请求上。

生成机制

1. 服务端生成，在 Http Response Header 中 Set-Cookie （我们项目中就是使用的这种）

2. 客户端生成，通过 document.cookie 设置

Cookie 设置初衷是用于**维持 HTTP 状态**，不用于**存储数据**。因此 cookie 有以下缺点：

1. 大小限制：每个 cookie 项只能存储 **4K** 数据
2. 性能浪费： cookie 附带在 http 请求上，数据量过大，会导致每个 http 请求就非常庞大，会很消耗流量和带宽。

前端和后端是同一个域名吗？

那肯定不是同一个

接口请求也是不一样的，所以跨域了

Web Storage - localStorage 和 session Storage

Web Storage：专注存储

Cookie：专注维持 HTTP 状态

LocalStorage

特点：以域名维度，浏览器的持久化存储方案，在域名下一直存在，及时关闭会话窗口或浏览器也不会被删除。

大小：每个项可以存储 5M 的数据

接口：同步接口，阻塞线程

使用方法：

```js
// 存储
localStorage.setItem('obj', obj);
// 取出
localStorage.getItem('obj');
// 移除
localStorage.removeItem('obj');
```

SessionStorage

特点：以域名维度，浏览器基于会话级别的存储方案，它只有在当前会话窗口存储的数据才可以读取到，一旦关闭当前页面或新开一个窗口，之前存储的数据是获取不到的。

大小：每个项能存储 5M 的数据

接口：同步接口，阻塞线程

使用方法：

```js
// 存储
sessionStorage.setItem('obj', obj);
// 取出
sessionStorage.getItem('obj');
// 移除
sessionStorage.removeItem('obj');
```

# Vue3 diff 算法

快速 diff 算法

# React

## 常用的一些 hooks

useState('初始值')

定义函数组件的状态

useEffect(fn, dependencies)

又称副作用 hooks。

作用：给没有生命周期的组件添加结束渲染的信号。

执行时机：在渲染结束之后执行。

useCallback(fn, dependencies)

是一个允许你在多次渲染中缓存函数的 React Hook

useMemo

useRef

useContxt

useEffect 和 useLayoutEffect 的区别？谁先执行？谁后执行？

https://blog.csdn.net/Likestarr/article/details/133863860

## 虚拟 DOM

最早是由 React 团队提出来的。

**Virtual Dom 是一种编程概念**。在这个概念里，UI 以一种理想化的，或者说“虚拟的”表现形式被保存于内存中。

也就是说，只要我们有一种方式，能够将真实的 DOM 的层次结构描述出来，那么这就是一个虚拟 DOM。

在 React 中，React 团队使用的是 JS 对象来对 DOM 结构进行一个描述。

虚拟 DOM 和 JS 对象之间的关系：前者是一种思想，后者是一种思想的具体实现。

### 为什么需要虚拟 DOM

使用虚拟 DOM 主要有两个方面的优势：

-   相较于 DOM 的体积优势和速度优势
-   多平台的渲染抽象能力

**相较于 DOM 的体积优势和速度优势**

首先我们需要明确一点，JS 层面的计算速度要比 DOM 层面的计算更快；

-   DOM 对象最终被浏览器渲染出来之前，浏览器会有很多工作要做（浏览器渲染原理）。
-   DOM 对象上面的属性非常多

```js
const div = document.createElement('div');
for (let i in div) {
    console.log(i + ' ');
}
```

操作 JS 对象的时间和操作 DOM 对象的时间是完全不一样的。

JS 层面的计算速度要高于 DOM 层面的计算速度。

此时有一个问题：虽然使用了 JS 对象来描述 UI，但是最终不还是要用原生 DOM API 去操作 DOM 吗？

虚拟 DOM 在第一次渲染页面的时候，其实并没有什么优势，速度肯定比直接操作原生 DOM API 要慢一些，虚拟 DOM 真正体现优势是在更新阶段。

根据 React 团队的研究，在渲染页面时，相比使用原生 DOM API，开发人员更倾向于使用 innerHTML

```js
let newP = document.createElement('p');
let newContent = document.createTextNode('this is a test');
newP.appendChild(newContent);
document.body.appendChild(newP);
```

```js
document.body.innerHTML = `
	<p>
		this is a test
	</p>
`;
```

因此在使用 innerHTML 的时候，就涉及到了两个层面的计算：

-   JS 层面：解析字符串
-   DOM 层面：创建对应的 DOM 节点

接下来我们加入虚拟 DOM 来进行对比：

|              | innerHTML           | 虚拟 DOM            |
| ------------ | ------------------- | ------------------- |
| JS 层面计算  | 解析字符串          | 创建 JS 对象        |
| DOM 层面计算 | 创建对应的 DOM 节点 | 创建对应的 DOM 节点 |

虚拟 DOM 真正发挥威力的时候，是在更新阶段

innerHTML 进行更新的时候，要全部重新赋值，这意味着之前创建的 DOM 节点需要全部销毁掉，然后重新进行创建

但是虚拟 DOM 只需要更新必要的 DOM 节点即可

|              | innerHTML               | 虚拟 DOM            |
| ------------ | ----------------------- | ------------------- |
| JS 层面计算  | 解析字符串              | 创建 JS 对象        |
| DOM 层面计算 | 销毁原来所有的 DOM 节点 | 修改必要的 DOM 节点 |
| DOM 层面计算 | 创建对应的 DOM 节点     |                     |

**多平台的渲染抽象能力**

UI = f (state) 这个公式进一步拆分可以拆分成两步：

-   根据自变量的变化计算出 UI
-   根据 UI 变化执行具体的宿主环境的 API

虚拟 DOM 只是对真实 UI 的一个描述，根据不同的宿主环境，可以执行不同的渲染代码：

-   浏览器、Node.js 宿主环境使用 ReactDOM 包
-   Native 宿主环境使用 ReactNative 包
-   Canvas、SVG 或者 VML（IE8）宿主环境使用 ReactArt 包
-   ReactTest 包用于渲染出 JS 对象，可以很方便的测试“不隶属于任何宿主环境的通用功能”

## React 中的虚拟 DOM

在 React 中通过 JSX 来描述 UI，JSX 最终会被转为一个叫做 createElement 方法的调用，调用该方法后就会得到虚拟 DOM 对象。

经过 Babel 编译后结果如下：

![image-20240305220900674](/Users/fiat_lux/Library/Application Support/typora-user-images/image-20240305220900674.png)

在源码中 createElement

```js

```

## 面试题：什么是虚拟 DOM？其优点有哪些？

react 使用 虚拟 dom 的好处？为什么会提高性能？

其实直接操作 dom 性能是最高的。

## React diff 的原理

# 03.06

# 03.06 面试

## 对项目有进行哪些配置吗

**环境配置**：根据项目运行的环境，配置不同的环境变量。例如，开发环境、测试环境和生产环境可能需要请求不同的 API 地址、token 等。

**依赖管理**：使用包管理器（如 npm、Maven、Gradle 等）来管理项目的依赖。这些依赖可能包括库、框架、插件等。

**代码规范**：配置代码规范检查工具（如 ESLint、TSLint、Checkstyle 等），以确保代码风格一致、符合规范，并减少潜在的错误。

**构建和部署**：配置构建工具（如 Webpack、Gradle Build 等）来自动化构建过程，包括代码编译、打包、测试等。同时，配置部署工具（如 Docker、Kubernetes 等）以自动化部署应用到服务器。

**安全性配置**：配置项目的安全策略，如身份验证、授权、加密等，以确保项目的安全性。

## React 里面常用的 Hooks

1. `useState`：用于在函数组件中添加状态。它接受一个初始状态值，并返回一个包含当前状态和一个更新状态的函数的数组。
2. `useEffect`：用于在函数组件中执行副作用操作，例如数据获取、订阅或手动更改 React 组件的 DOM。它接受一个函数作为参数，并在组件渲染后执行该函数。此外，还可以指定一个依赖项数组，以便在依赖项发生变化时重新运行副作用函数。
3. `useContext`：用于在函数组件中访问 React 的 Context API。它接受一个 Context 对象作为参数，并返回该 Context 的当前值。这样，你可以在函数组件中使用 Context，而无需手动传递 props。
4. `useReducer`：用于在函数组件中管理复杂的状态逻辑。它接受一个 reducer 函数和一个初始状态值作为参数，并返回一个包含当前状态和一个更新状态的 dispatch 函数的数组。使用`useReducer`可以更好地组织和管理状态更新逻辑，特别是在处理多个状态变量或执行异步操作时。
5. `useRef`：返回一个可变的 ref 对象，其`.current`属性被初始化为传入的参数。返回的 ref 对象在组件的整个生命周期内保持不变。这对于管理 DOM 对象、定时器或其他需要在组件生命周期内保持引用的值很有用。
6. `useMemo`：返回一个记忆化的值，该值只在依赖项数组发生变化时才会重新计算。这对于避免重复计算和提高性能很有用。
7. `useCallback`：返回一个记忆化的版本的回调函数，该回调函数载依赖项数组发生变化时才会更新。这对于防止不必要的渲染和提高性能很有用。

## 项目中使用的 redux

## 场景题：

### 前端页面会向后端去获取一些数据，用于列表展示，比如博客列表、菜谱列表，那数据量相对来说是比较大的，所以当接口请求数据较慢的时候，前端可以做哪些优化处理呢？

后端数据请求比较慢的时候，前端可以在体验上做一些优化，毕竟数据层面不是我们可以去掌控的。留大屏、loading、虚拟滚动、分页

当后端接口请求数据较慢时，前端可以采取以下几种优化处理策略：

1. **懒加载（Lazy Loading）**:
   对于非首屏显示的数据，如滚动列表中的项目，可以使用懒加载技术。这意味着在用户滚动到需要显示数据的区域之前，不会请求数据。这减少了初始加载时的请求量，提高了首屏加载速度。
2. **分页（Pagination）**:
   对于大量数据，不要一次性加载全部，而是将数据分为多个页面，用户可以按需加载。这减轻了服务器的压力，并降低了每次请求的数据量。
3. **数据缓存（Caching）**:
   对于不经常变更的数据，前端可以使用本地缓存技术（如 localStorage、sessionStorage 或 IndexedDB）来存储之前请求过的数据。当再次需要这些数据时，可以先检查本地缓存，如果数据存在且未过期，则直接使用缓存数据，避免重复请求后端。
4. **请求合并（Request Batching）**:
   如果多个请求可以合并为一个，那么应该尽量减少单独的请求次数。例如，当页面需要加载多个资源时，可以合并这些请求为一个请求。
5. **请求优化（Request Optimization）**:
   优化请求参数，减少不必要的字段或数据，确保请求的数据量尽可能小。此外，可以考虑使用 HTTP/2 或更高版本的协议，利用多路复用、头部压缩等技术来减少传输延迟。
6. **加载动画与占位符（Loading Animations & Placeholders）**:
   在数据加载过程中，为用户提供加载动画或占位符，使用户知道数据正在加载中，而不是让页面处于空白或停滞状态。
7. **预加载（Preloading）**:
   预加载是一种预测性加载技术，根据用户的操作习惯或页面上下文，提前加载用户可能需要的数据。例如，在滚动列表时，可以提前加载下一页的数据。
8. **延迟加载（Delayed Loading）**:
   对于一些非核心功能或用户可能不会立即注意到的数据，可以使用延迟加载。即先加载核心数据，然后等待一段时间（如用户滚动到页面底部）后再加载其他数据。
9. **服务端渲染（Server-Side Rendering, SSR）或预渲染（Prerendering）**:
   对于需要大量数据渲染的页面，可以考虑使用服务端渲染技术。这样，用户在首屏加载时就能看到完整的数据，而不是等待前端请求和渲染。预渲染则是一种在构建阶段生成静态 HTML 页面的技术，适用于内容不经常变更的场景。
10. **优化后端接口性能**:
    前端优化只是提升用户体验的一部分，同时也需要关注后端接口的性能。确保后端接口响应迅速，数据处理高效，以及数据库查询优化等。

综合应用以上策略，可以在很大程度上提升用户在加载大量数据时的体验。

### 跨域是怎么解决的

跨域问题是指在一个域名下的网页去请求另一个域名下的资源时，由于浏览器的同源策略限制，导致请求被阻止的问题。解决跨域问题有多种方法，以下是一些常见的解决方案：

1. JSONP（JSON with Padding）：JSONP 利用了 script 标签不受同源策略限制的特性，通过在前端动态创建 script 标签，并设置其 src 属性为需要跨域请求的 URL，从而绕过同源策略限制。但 JSONP 只支持 GET 请求，且存在安全风险，因此使用时需要谨慎。
2. CORS（Cross-Origin Resource Sharing）：CORS 是一种基于 HTTP 头的跨域解决方案，它允许服务器指定哪些域可以访问其资源。通过在响应头中添加 Access-Control-Allow-Origin 标签，服务器可以允许指定域的请求访问其资源。CORS 支持多种 HTTP 请求方法，包括 GET、POST、PUT、DELETE 等。
3. 代理：代理服务器可以作为一个中间人，将前端的请求先发送给代理服务器，再由代理服务器向目标服务器发起请求。由于代理服务器与目标服务器同源，因此可以绕过浏览器的同源策略限制。这种方法需要搭建代理服务器，并在前端配置请求地址为代理服务器的地址。
4. WebSocket：WebSocket 是一种基于 TCP 的全双工通信协议，它不受同源策略限制。因此，可以通过 WebSocket 实现跨域通信。但需要注意的是，WebSocket 的连接建立过程仍然受到同源策略的限制，因此需要在建立连接前进行一些额外的配置。

在实际应用中，可以根据具体的需求和场景选择合适的解决方案。例如，对于简单的 GET 请求，可以使用 JSONP；对于需要支持多种 HTTP 请求方法的情况，可以使用 CORS；对于需要绕过浏览器限制的情况，可以考虑使用代理或 WebSocket。

### 类组件和函数组件的生命周期对比

https://vue3js.cn/interview/React/class_function%20component.html#%E4%B8%89%E3%80%81%E5%8C%BA%E5%88%AB

React 框架生命周期（类组件与函数组件）：https://juejin.cn/post/6871728918643081230#heading-21

在 React 中，类组件和函数组件的生命周期存在显著的差异。

类组件的生命周期主要分为三个阶段：挂载阶段（Mounting）、更新阶段（Updating）和卸载阶段（Unmounting）。在挂载阶段，组件首次被渲染到页面上，主要执行的方法包括 constructor、componentDidMount 等。在更新阶段，组件的状态或属性发生变化，导致组件重新渲染，主要执行的方法包括 componentDidUpdate 等。在卸载阶段，组件从页面上被移除，主要执行的方法包括 componentWillUnmount 等。

相比之下，函数组件在 React 16.8 版本之前并没有生命周期的概念，因为它们只是纯函数，没有实例状态，也不支持生命周期方法。然而，随着 React Hooks 的引入，函数组件也开始拥有了类似生命周期的功能。通过使用 useEffect Hook，函数组件可以在特定的时间点执行副作用操作，这些时间点类似于类组件的生命周期方法。例如，useEffect 可以在组件挂载后执行（类似于 componentDidMount），在组件更新后执行（类似于 componentDidUpdate），以及在组件卸载前执行（类似于 componentWillUnmount）。

需要注意的是，虽然函数组件通过 useEffect 可以模拟类组件的生命周期，但两者在实现方式和灵活性上仍有所不同。类组件的生命周期方法是在类的实例上调用的，因此可以通过 this 关键字访问组件的实例属性和方法。而函数组件则没有实例概念，它们通过参数接收属性和状态，并通过返回值来渲染界面。这种差异使得函数组件更加轻量级和易于复用，但同时也需要开发者更加熟悉 React Hooks 的使用方式。

### 如果想在页面中发送请求，类组件和函数组件分别写在哪个生命周期

比如想在页面加载的时候发送请求，应该写在哪个生命周期

**类组件**：

React 中请求通常在**componentDidMount 生命周期函数中发送**。 这个生命周期函数在组件已经挂载到页面上，并且可以操作 DOM 元素时被调用。

**函数组件**：

useEffect

### useEffect 的参数有哪些？有哪几种写法

有两个参数，第一个参数是函数类型，第二个是数组

写法：

1. 不传递第二个参数：会导致每次渲染都会执行 useEffect。当它运行时，它获取数据并更新状态。然后，一旦状态更新，组件将重新呈现，这将再次触发 useEffect，这就是问题所在。

    ```js
    useEffect(() => {
        console.log(1);
        setNumber(num);
    });
    ```

2. 第二个参数为空数组：在挂载和卸载时执行

    ```js
    useEffect(() => {
        console.log(1);
    }, []);
    ```

3. 第二个参数为数组，有一个或多个值：依赖值更新时执行

    ```js
    // 依赖一个值
    useEffect(() => {
        console.log(1);
    }, [val]);

    // 依赖多个值
    useEffect(() => {
        console.log(1);
    }, [val, num]);
    ```

4. 第一个函数参数中 return 一个方法：该方法在组件销毁的时候会被调用

    ```js
    useEffect(() => {
        const timer = setInterval(() => {
            console.log(1);
        }, 1000);
        console.log(1);
        return () => {
            clearInterval(timer);
        };
    }, []);
    ```

### lodash 常用的方法有哪些

http://www.qyhever.com/pages/js/common-use-lodash-methods.html

## antd 的图表在使用时，哪个图表给你带来了困扰？有问题，但是也解决了

## upload 上传的时候，文件大小超过 5M 就上传失败，应该怎么处理

## upload 上传组件的进度条样式和 UI 的不一样，现在是上下布局，希望改成左右布局，重构进度条部分的功能，应该怎么做？

让后端提供文件读取的百分比

## 博客分享链接给别人的时候，我希望别人点进来之后只能看到博客正文，其他的侧边栏之类的都看不到，应该怎么做？

隐藏样式

比如 url 多携带一个参数，用来判断是否需要隐藏元素

要在前端实现这样的功能，你可以通过结合 URL 参数和 JavaScript/CSS 来控制页面上元素的显示与隐藏。下面是一个详细的步骤说明：

### 步骤 1: 定义 URL 参数

首先，你需要为你的分享链接定义一个 URL 参数，比如`?view=clean`，这样链接看起来可能是这样的：`https://yourblog.com/your-post?view=clean`。

### 步骤 2: 读取 URL 参数

接下来，你需要在前端 JavaScript 代码中读取这个 URL 参数。你可以使用原生的 JavaScript 方法，也可以使用一些库（如 jQuery）来简化这个过程。以下是一个使用原生 JavaScript 读取 URL 参数的例子：

```js
function getQueryParam(name) {
    const searchParams = new URLSearchParams(window.location.search);
    return searchParams.get(name);
}

const viewParam = getQueryParam('view');
```

### 步骤 3: 根据参数隐藏元素

现在，你可以根据读取到的参数值来决定是否隐藏某些元素。比如，如果`viewParam`的值是`clean`，你就隐藏侧边栏和页脚：

```js
if (viewParam === 'clean') {
    // 隐藏侧边栏
    const sidebar = document.getElementById('sidebar');
    if (sidebar) {
        sidebar.style.display = 'none';
    }

    // 隐藏页脚
    const footer = document.getElementById('footer');
    if (footer) {
        footer.style.display = 'none';
    }

    // 隐藏其他任何你不想显示的元素...
}
```

### 步骤 4: 在适当的时候执行 JavaScript 代码

确保你的 JavaScript 代码在 DOM 加载完成后执行。你可以将上述代码放在`window.onload`事件处理器中，或者使用`DOMContentLoaded`事件，或者将`<script>`标签放在 HTML 文档的底部。

```js
document.addEventListener('DOMContentLoaded', function () {
    // ...将上述代码放在这里...
});
```

### 步骤 5: 测试

最后，测试你的实现是否按预期工作。尝试访问带有`?view=clean`参数的 URL，并确认侧边栏和其他不想要的元素确实被隐藏了。同时，也要确保在没有该参数的情况下，页面正常显示。

### 注意事项

-   **安全性**：这种方法仅依赖于前端技术，因此并不是完全安全的。用户仍然可以通过修改 URL 或禁用 JavaScript 来查看原本被隐藏的内容。
-   **可维护性**：如果你的博客模板经常变动，确保更新你的 JavaScript 代码以匹配最新的 DOM 结构。
-   **性能**：虽然这种方法对性能的影响通常很小，但最好还是尽量减少不必要的 DOM 操作和页面重绘。
-   **用户体验**：考虑分享页面的用户体验，确保即使在“清洁”视图下，用户也能轻松地导航回你的博客的其他部分或找到他们需要的信息。

数据处理、权限、图表、

## 上传文件请求函数

这段代码定义了一个名为 `uploadProductFile` 的函数，该函数用于上传产品文件。下面是对这段代码的详细解析：

### 函数参数

-   `req`: 一个对象，其中至少包含 `onProgress`, `onSuccess`, 和 `onError` 三个方法，用于在上传过程中和上传完成后处理进度、成功和错误的情况。
-   `callback`: 一个回调函数，用于在上传完成后执行。

### 函数逻辑

1. **触发进度事件**:

```js
req.onProgress({ percent: 10 });
```

当函数开始时，首先触发一个进度事件，表示上传开始，进度为 10%。

2. **创建 FormData 对象**:

```js
var formData = new FormData();
formData.append('file', req.file);
```

使用 `FormData` 对象来准备要上传的数据。这里假设 `req.file` 是要上传的文件。

3. **发送 AJAX 请求**:
   使用 `$.ajax` 发送一个 POST 请求到 `apiHost + "product/uploadExecl"`。

4. **请求头**：

    ```js
    headers: {
      Authorization: getUserToken(),
    }
    ```

    在请求头中添加一个 `Authorization` 字段，其值通过调用 `getUserToken()` 函数获取。

5. **内容类型和处理数据**：

    ```js
    contentType: false, // 注意这里应设为false
    processData: false,
    ```

    由于我们使用的是 `FormData` 对象，所以需要将 `contentType` 和 `processData` 都设置为 `false`，以确保文件能够被正确上传。

6. **自定义 XMLHttpRequest**:

    ```js
    xhr: function () {
      var xhr = new XMLHttpRequest();
      xhr.upload.addEventListener('progress', function (e) {
        var progressRate = (e.loaded / e.total) * 100;
        req.onProgress({ percent: progressRate })
      })
      return xhr;
    }
    ```

    这里自定义了 `XMLHttpRequest` 对象，并为上传过程添加了进度监听。每当上传进度更新时，都会调用 `req.onProgress` 方法，并传递当前的进度百分比。

7. **成功和失败的处理**:

    ```js
    .done(function (data) {
      req.onProgress({ percent: 100 });
      req.onSuccess(data);
      callback(data);
    })
    .fail(function (data) {
      req.onProgress({ percent: 0 });
      req.onError(data);
      callback(data);
    })
    .fail(function (data) {
      req.onProgress({ percent: 0 });
      req.onError(data);
      callback(data);
    });
    ```

    使用 `.done` 方法处理上传成功的情况，使用 `.fail` 方法处理上传失败的情况。注意这里 `.fail` 方法被调用了两次，这可能是代码的重复，应该删除一个。

### 总结

这段代码定义了一个用于上传文件的函数，它使用 `FormData` 对象和 `$.ajax` 方法来发送文件，并在上传过程中和上传完成后通过回调函数通知调用者上传的进度和结果。但是，代码中存在一些可能的问题，如 `.fail` 方法的重复调用和没有处理可能的网络错误等。

```js
//批量上传商品
export function uploadProductFile(req, callback) {
    req.onProgress({ percent: 10 });
    var formData = new FormData();

    formData.append('file', req.file);

    $.ajax({
        url: apiHost + 'product/uploadExecl',
        method: 'POST',
        data: formData,
        headers: {
            Authorization: getUserToken(),
        },
        contentType: false, // 注意这里应设为false
        processData: false,
        cache: false,
        xhr: function () {
            //请求条
            var xhr = new XMLHttpRequest();
            xhr.upload.addEventListener('progress', function (e) {
                var progressRate = (e.loaded / e.total) * 100;
                req.onProgress({ percent: progressRate });
            });

            return xhr;
        },
    })
        .done(function (data) {
            req.onProgress({ percent: 100 });
            req.onSuccess(data);
            callback(data);
        })
        .fail(function (data) {
            req.onProgress({ percent: 0 });
            req.onError(data);
            callback(data);
        })
        .fail(function (data) {
            req.onProgress({ percent: 0 });
            req.onError(data);
            callback(data);
        });
}
```

https://blog.csdn.net/Likestarr/article/details/133863860

https://blog.csdn.net/runrun117/article/details/124727815


