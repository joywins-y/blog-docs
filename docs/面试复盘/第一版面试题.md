# 前端判断数据类型

1. typeof

   对象（{}）、数组（[])、null 的结果都是 object

   新数据类型如Symbol、BigInt，无法识别

2. instanceof

   无法判断基本数据类型和null

3. Object.prototype.toString.call()

   语法相对复杂，但是可以区分数组、函数等引用数据类型

4. Array.isArray()

   只能判断数组类型，精准判断数组

typeof 和 instanceof 的区别：

返回值类型：typeof 返回一个表示数据类型的字符串，instanceof 返回一个布尔值，表示是否是指定类的实例

判断范围：typeof 相对来说可以判断的类型更多，instanceof 只能用来判断对象类型（也就是两者互补）。

精确性：typeof 对基本数据类型判断比较精确，对于引用类型则无法进一步区分。instanceof 可以准确的判断引用类型。



# 防抖和节流

## 防抖

防抖是指在用户事件被触发 n 秒后再执行回调逻辑，如果在这 n 秒内事件再次被触发，则重新计时。换言之，程序只执行最后一次触发事件，以此来优化性能。

实现代码：

```js
const debounce = (fn, delay) => {
  let timer = null;
  return (...args) => {
   	clearTimeout(timer);
    timer = setTimeout(()=>{
      fn(args);
    }, delay)
  }
}
```

## 节流

节流是指当遇到连续用户事件时，以 n 秒为间隔进行阻断，目的是减少同一时间段内连续事件的触发频率，以此来提升性能。

实现代码：

```js
const trottle = (fn, delay) => {
  let timer = null;
  return function (...args) {
    if(timer) return;
    timer = setTimeout(() => {
      fn(args);
      clearTimeout(timer);
      timer = null;
    }, delay)
  }
}
```

![image-20240312192537719](/Users/fiat_lux/Library/Application Support/typora-user-images/image-20240312192537719.png)

# 深拷贝

## JSON.parse(JSON.stringify(obj))

缺点：JSON.stringify() 会丢失部分属性

关于 **key 为 Symbol** 的会忽略掉，值为 **undefined** 的会忽略掉，**NaN** 变成 null，**函数**会忽略掉，**Infinity** 会变成 null

总结来说：

无法复制函数和 undefined；

如果对象中包含循环引用，会抛出错误；

对于包含Symbol、RegExp等特殊类型的对象，可能无法正确工作

```js
const obj = {
	[Symbol.for('key1')]: 'a',
  b: undefined,
  c: NaN,
	d: () => { return null },
  e: Infinity,
  f: null
}
console.log(JSON.parse(JSON.stringify(obj))); // {c: null, e: null, f: null}
```

![image-20240305135515117](/Users/fiat_lux/Library/Application Support/typora-user-images/image-20240305135515117.png)

## 使用 js 工具库 lodash

```js
const obj = {a: 1, b: 2, c: 3};
const newObj = _.cloneDeep(obj);
```

## 递归复制

```js
function deepClone(obj) {
  // 先判断 obj 的数据类型
  if(obj === null) return obj; // obj 为 null
  if(obj instanceof Date) return new Date(obj); // obj 为 Date
  if(obj instanceof RegExp) return new RegExp(obj); // obj 为 RegExp
  if(typeof obj !== 'object') return obj;
  let cloneObj = new obj.constructor();
  for(let key in obj) {
    if(obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key]);
    }
  }
  return cloneObj;
}
```



扩展：

JSON.stringify(value, replacer, space)

参数一：value      表示要被序列化的对象，接受对象或数组类型

参数二：replacer 用于标记需要序列化的属性，接受数组和函数类型

参数三：space 用于描述序列化后的缩进字符数，用于美化格式

使用场景：

1. localStorage 的存储

​		localStorage 只能存储字符串类型，kv（key，value） 结构

```js
const obj = {a: 1, b: 2, c: 3};
// 序列化要存储的数据: JSON.stringify(obj)
// 存储
localStorage.setItem('obj', JSON.stringify(obj));
// 取出
localStorage.getItem('obj'); // '{"a":1,"b":2,"c":3}'
// 移除
localStorage.removeItem('obj');
```

2. 对象的深拷贝

   ```js
   const obj = {a: 1, b: 2, c: 3};
   const objA = obj;
   const objB = JSON.parse(JSON.stringify(obj));
   // 修改
   objA.a = 11;
   console.log(obj); // {a: 11, b: 2, c: 3}
   console.log(objA); // {a: 11, b: 2, c: 3}
   
   objB.a = 123;
   console.log(obj); // {a: 11, b: 2, c: 3}
   console.log(objB); // {a: 123, b: 2, c: 3}
   ```

3. 删除对象属性

   ```js
   const obj = {a: 1, b: 2, c: 3};
   const str = JSON.stringify(obj, (key, value) =>{
     if(key === 'b') {
       return undefined;
     }
     return value;
   });
   console.log(str); // '{"a":1,"c":3}'
   const objA = JSON.parse(str);
   console.log(objA); // {a: 1, c: 3}
   ```







# 前端跨域

跨域是前端解决的范畴



什么时候会发生跨域

跨域是由于浏览器的同源策略（协议、域名、）所导致的，是发生在 页面 到 服务端 请求的过程中



项目中怎么解决这个跨域问题的

1. Nginx 反向代理
2. 搭建 BFF 层





了解后端处理跨域的原理吗

可以使用nginx，但是我们项目后端是在微服务中处理跨域



cookie 和 localStorage 的区别



项目中的登录是用的cookie还是localStorage来保存token的？

cookie

用户在浏览器这边进行登录接口请求，服务端收到这个请求之后，在用户名和密码都正确的情况下，服务器在向浏览器返回登录结果的时候，会生成一个cookie，并且在 Http Response Header 中 Set-Cookie。这样，当浏览器再次请求服务端时，都会同步的带上 cookie，cookie 会附带在每个 Http 请求上。

生成机制

1. 服务端生成，在 Http Response Header 中 Set-Cookie （我们项目中就是使用的这种）

2. 客户端生成，通过 document.cookie 设置



Cookie 设置初衷是用于**维持 HTTP 状态**，不用于**存储数据**。因此 cookie 有以下缺点：

1. 大小限制：每个 cookie 项只能存储 **4K** 数据
2. 性能浪费： cookie 附带在 http 请求上，数据量过大，会导致每个 http 请求就非常庞大，会很消耗流量和带宽。



前端和后端是同一个域名吗？

那肯定不是同一个

接口请求也是不一样的，所以跨域了





react 

常用的一些hooks

useEffect 和 useLayoutEffect 的区别？谁先执行？谁后执行？

react 使用 虚拟 dom 的好处？为什么会提高性能？

直接操作dom性能是最高的。

react diff 的原理

