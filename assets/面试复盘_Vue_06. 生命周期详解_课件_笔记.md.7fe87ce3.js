import{_ as e,o,c as d,V as c}from"./chunks/framework.bd00fe0c.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"面试复盘/Vue/06. 生命周期详解/课件/笔记.md","filePath":"面试复盘/Vue/06. 生命周期详解/课件/笔记.md","lastUpdated":1712573589000}'),t={name:"面试复盘/Vue/06. 生命周期详解/课件/笔记.md"},p=c('<blockquote><p>面试题：<code>new Vue</code>之后，发生了什么？数据改变后，又发生了什么？</p></blockquote><img src="http://mdrs.yuanjin.tech/img/20210302155735.png" alt="image-20210302155735758" style="zoom:33%;"><ol><li><p>创建vue实例和创建组件的流程基本一致</p><ol><li><p>首先做一些初始化的操作，主要是设置一些私有属性到实例中</p></li><li><p><strong>运行生命周期钩子函数<code>beforeCreate</code></strong></p></li><li><p>进入注入流程：处理属性、computed、methods、data、provide、inject，最后使用代理模式将它们挂载到实例中</p></li><li><p><strong>运行生命周期钩子函数<code>created</code></strong></p></li><li><p>生成<code>render</code>函数：如果有配置，直接使用配置的<code>render</code>，如果没有，使用运行时编译器，把模板编译为<code>render</code></p></li><li><p><strong>运行生命周期钩子函数<code>beforeMount</code></strong></p></li><li><p>创建一个<code>Watcher</code>，传入一个函数<code>updateComponent</code>，该函数会运行<code>render</code>，把得到的<code>vnode</code>再传入<code>_update</code>函数执行。</p><p>在执行<code>render</code>函数的过程中，会收集所有依赖，将来依赖变化时会重新运行<code>updateComponent</code>函数</p><p>在执行<code>_update</code>函数的过程中，触发<code>patch</code>函数，由于目前没有旧树，因此直接为当前的虚拟dom树的每一个普通节点生成elm属性，即真实dom。</p><p>如果遇到创建一个组件的vnode，则会进入组件实例化流程，该流程和创建vue实例流程基本相同，最终会把创建好的组件实例挂载vnode的<code>componentInstance</code>属性中，以便复用。</p></li><li><p><strong>运行生命周期钩子函数<code>mounted</code></strong></p></li></ol></li><li><p>重渲染？</p><ol><li><p>数据变化后，所有依赖该数据的<code>Watcher</code>均会重新运行，这里仅考虑<code>updateComponent</code>函数对应的<code>Watcher</code></p></li><li><p><code>Watcher</code>会被调度器放到<code>nextTick</code>中运行，也就是微队列中，这样是为了避免多个依赖的数据同时改变后被多次执行</p></li><li><p><strong>运行生命周期钩子函数<code>beforeUpdate</code></strong></p></li><li><p><code>updateComponent</code>函数重新执行</p><p>在执行<code>render</code>函数的过程中，会去掉之前的依赖，重新收集所有依赖，将来依赖变化时会重新运行<code>updateComponent</code>函数</p><p>在执行<code>_update</code>函数的过程中，触发<code>patch</code>函数。</p><p>新旧两棵树进行对比。</p><p>普通<code>html</code>节点的对比会导致真实节点被创建、删除、移动、更新</p><p>组件节点的对比会导致组件被创建、删除、移动、更新</p><p>当新组件需要创建时，进入实例化流程</p><p>当旧组件需要删除时，会调用旧组件的<code>$destroy</code>方法删除组件，该方法会先触发<strong>生命周期钩子函数<code>beforeDestroy</code></strong>，然后递归调用子组件的<code>$destroy</code>方法，然后触发<strong>生命周期钩子函数<code>destroyed</code></strong></p><p>当组件属性更新时，相当于组件的<code>updateComponent</code>函数被重新触发执行，进入重渲染流程，和本节相同。</p></li><li><p><strong>运行生命周期钩子函数<code>updated</code></strong></p></li></ol></li></ol><p>​</p><p>​</p>',5),n=[p];function r(l,a,i,s,_,m){return o(),d("div",null,n)}const h=e(t,[["render",r]]);export{g as __pageData,h as default};
