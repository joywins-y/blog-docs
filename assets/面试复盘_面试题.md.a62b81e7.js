import{_ as e,o as a,c as t,V as l}from"./chunks/framework.bd00fe0c.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"面试复盘/面试题.md","filePath":"面试复盘/面试题.md","lastUpdated":null}'),p={name:"面试复盘/面试题.md"},i=l('<h2 id="面试题-谈一谈你对前端框架的理解" tabindex="-1">面试题：谈一谈你对前端框架的理解 <a class="header-anchor" href="#面试题-谈一谈你对前端框架的理解" aria-label="Permalink to &quot;面试题：谈一谈你对前端框架的理解&quot;">​</a></h2><p>在早期使用 jQuery 时代，那时的开发人员需要手动的去操作 DOM 节点，那个时候流行的还是 MPA 模式，各个页面的 JS 代码量还在能够接受的范围。</p><p>但是随着单页应用的流行，客户端的 JS 代码量出现井喷，此时如果还是采用传统的手动操作 DOM 的方式，对于开发人员来讲有非常大的心智负担。</p><p>此时就出现了能够基于状态声明式渲染以及提供组件开发模式的库，例如 Vue 和 React。这两者本质上仅仅是构建 UI 的库，但是随着应用复杂度的提升，还需要前端路由方案、状态管理方案，所以有了 vue-router、react-router、vuex、redux 等周边生态产品。</p><p>Vue 或 React 和这些周边生态产品共同构成了一个技术栈（全家桶），现在我们会将 React 或者 Vue 称之为框架，这可以算是一种约定俗成的说法。</p><p>一款现代前端框架，在它本身以及它的周边生态中，至少要包含以下几个方面：</p><ul><li>基于状态的声明式渲染</li><li>支持组件化开发</li><li>客户端路由方案</li><li>状态管理方案</li></ul><p>比如：</p><ul><li><p>Umijs 是一款基于 React 、内置路由、构建、部署等功能的框架</p></li><li><p>Nextjs 是一款基于 React、支持 SSR、SSG 两大功能的服务端框架</p></li></ul><h2 id="面试题-react-和-vue-描述页面的区别" tabindex="-1">面试题：React 和 Vue 描述页面的区别 <a class="header-anchor" href="#面试题-react-和-vue-描述页面的区别" aria-label="Permalink to &quot;面试题：React 和 Vue 描述页面的区别&quot;">​</a></h2><p>在 React 中，使用 JSX 来描述 UI。因为 React 团队认为 UI 本质上与逻辑存在耦合的部分，作为前端工程师，JS 是用的最多的，如果同样使用 JS 来描述 UI，就可以让 UI 和逻辑配合的更加密切。</p><p>使用 JS 来描述页面，可以更加灵活，主要体现在：</p><ul><li>可以在 if 语句和 for 循环中使用 JSX</li><li>可以将 JSX 赋值给变量</li><li>可以把 JSX 当作参数传入，以及在函数中返回 JSX</li></ul><p>而模版语言的历史则需要从后端说起。早期在前后端未分离时代，后端有各种各样的模板引擎，其本质是扩展了 HTML，在 HTML 中加入逻辑相关的语法，之后再动态的填充数据进去。如果单看 Vue 中的模板语法，实际上和后端语言中的各种模板引擎是非常相似的。</p><p>总结起来就是：</p><p>模板语法的出发点是，既然前端框架使用 HTML 来描述 UI，那么就扩展 HTML 语法，使它能够描述逻辑，也就是**”从 UI 出发，扩展 UI，在 UI 中能够描述逻辑“**。</p><p>而 JSX 的出发点是，既然前端使用 JS 来描述逻辑，那么就扩展 JS 语法，让它能够描述 UI，也就是**”从逻辑出发，扩展逻辑，在逻辑中能够描述 UI“**。</p><p>虽然这两者都达到了同样的目的，但是对框架的实现产生了不同的影响。</p>',18),r=[i];function c(o,u,_,s,n,d){return a(),t("div",null,r)}const J=e(p,[["render",c]]);export{h as __pageData,J as default};
