import{_ as s,o as a,c as l,V as n}from"./chunks/framework.bd00fe0c.js";const A=JSON.parse('{"title":"3 月 4 号面试题","description":"","frontmatter":{},"headers":[],"relativePath":"面试复盘/2024年3月4号.md","filePath":"面试复盘/2024年3月4号.md","lastUpdated":1710093091000}'),o={name:"面试复盘/2024年3月4号.md"},p=n(`<h1 id="_3-月-4-号面试题" tabindex="-1">3 月 4 号面试题 <a class="header-anchor" href="#_3-月-4-号面试题" aria-label="Permalink to &quot;3 月 4 号面试题&quot;">​</a></h1><h2 id="_1-前端判断数据类型的方法有哪些" tabindex="-1">1. 前端判断数据类型的方法有哪些 <a class="header-anchor" href="#_1-前端判断数据类型的方法有哪些" aria-label="Permalink to &quot;1. 前端判断数据类型的方法有哪些&quot;">​</a></h2><p>8 种数据类型：undefined、null、Number、Boolean、String、Object、Symbol、BigInt</p><p>其中基本数据类型：undefined、null、number、boolean、string 存储在栈中，存取方式是先进后出</p><p>引用数据类型：对象（object）、数组（array）、函数（function）存储在堆中，按优先级排序，优先级可以按照大小来规定。</p><ol><li>typeof</li></ol><p>数组、对象、null 都会判断为 object，其他类型正确判断</p><ol start="2"><li>instanceof</li></ol><p>只能正确判断引用数据类型，不能判断基本数据类型 instanceof 可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性</p><ol start="3"><li>constructor</li></ol><p>constructor 有两个作用：一是判断数据类型（可以判断全部类型），二是对象实例通过 constructor 对象访问它的构造函数。 需要注意的是，如果创建一个对象来改变它的原型，constructor 就不能用来判断数据类型了。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> Fn </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">Fn</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">prototype </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Array</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> f </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Fn</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(Fn</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">constructor </span><span style="color:#89DDFF;">===</span><span style="color:#BABED8;"> Function)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(f</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">constructor </span><span style="color:#89DDFF;">===</span><span style="color:#BABED8;"> Fn)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// false</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(f</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">constructor </span><span style="color:#89DDFF;">===</span><span style="color:#BABED8;"> Array)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span></code></pre></div><p>解析：<code>f.constructor</code> 也即<code>f.__proto__.constructor</code>， <strong>实例对象的<code>__proto__</code>指向其构造函数的原型对象 prototype</strong>。 故<code>f.__proto__</code>等价于 <code>Fn.prototype</code>， 所以<code>f.__proto__.constructor === Fn.prototype.constructor</code> <code>Fn.prototype</code>是<code>Array</code>的实例对象 实例对象的<code>constructor</code>属性指向构造函数本身 所以<code>Fn.prototype.constructor === Array</code></p><p>其实就是<code>new Array()</code>得到的对象覆盖了原来的<code>Fn.prototype</code>，所以<code>Fn.prototype.constructor</code>不再指向<code>Fn</code>，而是指向了<code>Array</code></p><ol start="4"><li>Object.prototype.toString.call()</li></ol><p>Object.prototype.toString.call() 是使用 Object 对象的原型方法 toString 来判断数据类型</p><p>扩展：同样是检测对象 obj 调用 toString 方法，obj.toString() 的结果和 Object.prototype.toString.call(obj)的结果不一样，这是为什么？ 这是因为 toString 是 Object 的原型方法，而<strong>Array、function 等类型作为 Object 的实例，都重写了 toString 方法</strong>。不同的对象类型调用 toString 方法时，根据原型链的知识，调用的是对应的重写之后的 toString 方法（function 类型返回内容为函数体的字符串，Array 类型返回元素组成的字符串），而不会去调用 Object 上原型 toString 方法（返回对象的具体类型），所以采用 obj.toString()不能得到其对象类型，只能将 obj 转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用 Object 原型上的 toString 方法。</p><h3 id="补充提问-typeof-和-instanceof-的区别" tabindex="-1">补充提问：typeof 和 instanceof 的区别 <a class="header-anchor" href="#补充提问-typeof-和-instanceof-的区别" aria-label="Permalink to &quot;补充提问：typeof 和 instanceof 的区别&quot;">​</a></h3><ol><li>返回值类型不一样：typeof 返回一个表示数据类型的字符串，instanceof 返回一个布尔值，表示是否为指定类的实例。</li><li>判断范围和精确性不一样：typeof 对基本数据类型判断较精确，但是对引用类型无法进一步区分。对于对象、数组、null 会判断成 object。instanceof 判断引用类型更精确，无法判断基本数据类型。</li></ol><h3 id="补充提问-typeof-为什么判断-null-时会判断成-object-自己补充" tabindex="-1">补充提问：typeof 为什么判断 null 时会判断成 object（自己补充） <a class="header-anchor" href="#补充提问-typeof-为什么判断-null-时会判断成-object-自己补充" aria-label="Permalink to &quot;补充提问：typeof 为什么判断 null 时会判断成 object（自己补充）&quot;">​</a></h3><p>在 JS 第一个版本之后，所有值都存储在 32 位的单元中，每个单元包含一个小的**类型标签（1-3 bits）**以及当前要存储值的真实数据。类型标签存储在每个单位的低位中，共有 5 种数据类型：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F78C6C;">000</span><span style="color:#BABED8;">: object     </span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;"> 当前存储的数据指向一个对象</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">: int        </span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;"> 当前存储的数据是一个 </span><span style="color:#F78C6C;">31</span><span style="color:#BABED8;"> 位的有符号整数</span></span>
<span class="line"><span style="color:#F78C6C;">010</span><span style="color:#BABED8;">: double     </span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;"> 当前存储的数据指向一个双精度的浮点数</span></span>
<span class="line"><span style="color:#F78C6C;">100</span><span style="color:#BABED8;">: string     </span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;"> 当前存储的数据指向一个字符串</span></span>
<span class="line"><span style="color:#F78C6C;">110</span><span style="color:#BABED8;">: boolean    </span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;"> 当前存储的数据是布尔值</span></span></code></pre></div><p>如果最低位是 1，则类型标签标志位的长度只有 1 位；如果最低位是 0，则类型标签标志位的长度占 3 位，为存储其他四种数据类型提供了额外两个 bit 的长度。 有两种特殊数据类型：</p><ul><li>undefined 的值是(-2^30)(一个超出整数范围的数字)</li><li>null 的值是机器码 NULL 指针（null 指针的值全是 0）</li></ul><p>那么也就是说，null 的 类型标签也是 000，和 Object 的类型标签一样，所以会被判定为 Object。</p><h2 id="_2-防抖和节流" tabindex="-1">2. 防抖和节流 <a class="header-anchor" href="#_2-防抖和节流" aria-label="Permalink to &quot;2. 防抖和节流&quot;">​</a></h2><h3 id="防抖" tabindex="-1">防抖 <a class="header-anchor" href="#防抖" aria-label="Permalink to &quot;防抖&quot;">​</a></h3><p>防抖是指用户事件被触发 n 秒后执行回调逻辑，如果在这 n 秒内，事件再次被触发，则重新计时。换言之，程序只执行最后一次触发事件，一次来优化性能。</p><p>应用场景：</p><ul><li>搜索框输入的时候，用户输入 1-9，不加防抖页面会渲染 9 次。加上防抖之后，页面渲染一次即可。</li><li>防止多次提交按钮，只执行最后一次提交</li></ul><p>实现代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> debounce </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">fn</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">delay</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">timer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(...</span><span style="color:#BABED8;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">clearTimeout</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">timer</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 先清除定时器</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">timer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 然后设置定时器，执行回调逻辑</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#82AAFF;">fn</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">args</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">delay</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><h3 id="节流" tabindex="-1">节流 <a class="header-anchor" href="#节流" aria-label="Permalink to &quot;节流&quot;">​</a></h3><p>节流是指当用户遇到连续用户事件时，以 n 秒为间隔进行阻断，目的是减少同一时间段内连续事件的触发频率，以此来提升性能。</p><p>应用场景：</p><ul><li>拖拽场景：固定时间内执行一次，防止超高频次触发位置变动</li><li>缩放场景：监控浏览器 resize（调整浏览器窗口大小，触发 resize 事件）</li><li>动画场景：避免短时间内多次触发动画引发性能问题</li></ul><p>实现代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> trottle </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">fn</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">delay</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">timer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(...</span><span style="color:#BABED8;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">timer</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// timer 存在，说明已经执行了回调函数，暂时不再执行</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">timer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 先执行回调逻辑，再清除定时器</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#82AAFF;">fn</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">args</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#82AAFF;">clearTimeout</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">timer</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#BABED8;">timer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">delay</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><h2 id="_3-深拷贝" tabindex="-1">3. 深拷贝 <a class="header-anchor" href="#_3-深拷贝" aria-label="Permalink to &quot;3. 深拷贝&quot;">​</a></h2><ol><li>JSON.parse(JSON.stringify(obj)) <ul><li>遇到 undefined 和函数会报错；</li><li>对象里面 key 为 Symbol、值为 undefined、值为函数，都会被忽略；</li><li>对象里面值为 NaN、值为 Infinity 会变成 null。</li></ul></li><li>js 工具库 lodash.cloneDeep(obj)</li><li>递归复制</li><li>Object.assign({}, obj) <ul><li>只深拷贝第一层</li></ul></li></ol><blockquote><p>扩展： JSON.parse 和 JSON.stringify 还可以用于删除对象属性</p></blockquote><h2 id="_4-前端跨域" tabindex="-1">4. 前端跨域 <a class="header-anchor" href="#_4-前端跨域" aria-label="Permalink to &quot;4. 前端跨域&quot;">​</a></h2><h3 id="什么时候发生跨域" tabindex="-1">什么时候发生跨域 <a class="header-anchor" href="#什么时候发生跨域" aria-label="Permalink to &quot;什么时候发生跨域&quot;">​</a></h3><p>跨域是由于浏览器的同源策略所导致的，是发生在<strong>页面</strong>到<strong>服务端</strong>请求的过程中</p><h3 id="怎么解决跨域" tabindex="-1">怎么解决跨域 <a class="header-anchor" href="#怎么解决跨域" aria-label="Permalink to &quot;怎么解决跨域&quot;">​</a></h3><ol><li>Nginx 反向代理（可以使用 docker 开镜像）</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">server </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">listen</span><span style="color:#F07178;">      </span><span style="color:#F78C6C;">5000</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">server_name</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">127.0</span><span style="color:#89DDFF;">.</span><span style="color:#F78C6C;">0.1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">location</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">/</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_pass</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">http</span><span style="color:#89DDFF;">:</span><span style="color:#676E95;font-style:italic;">//127.0.0.1:3000;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_set_header</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">Host</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">$host</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_set_header</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">X</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Real</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">IP</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">$remote_addr</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_set_header</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">X</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Forwarded</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">For</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">$proxy_add_x_forwarded_for</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">location</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">/</span><span style="color:#BABED8;">api</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_pass</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">http</span><span style="color:#89DDFF;">:</span><span style="color:#676E95;font-style:italic;">//127.0.0.1:4000;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_set_header</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">Host</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">$host</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_set_header</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">X</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Real</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">IP</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">$remote_addr</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_set_header</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">X</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Forwarded</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">For</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">$proxy_add_x_forwarded_for</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><ol start="2"><li>搭建 BFF 层来解决跨域问题（Node 环境）</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> KoaRouter </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">require</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">koa-router</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> router </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">KoaROuter</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">router</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">post</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/api/task</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">async</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">ctx</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">next</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">res</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">axios</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">post</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">http://127.0.0.1:4000/api/task</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">ctx</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">body</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">res</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">data</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">use</span><span style="color:#BABED8;">(router</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">routes</span><span style="color:#BABED8;">())</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">use</span><span style="color:#BABED8;">(router</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">allowedMethos</span><span style="color:#BABED8;">())</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h4 id="延伸问题-引入-bff-层有什么好处" tabindex="-1">延伸问题：引入 BFF 层有什么好处 <a class="header-anchor" href="#延伸问题-引入-bff-层有什么好处" aria-label="Permalink to &quot;延伸问题：引入 BFF 层有什么好处&quot;">​</a></h4><p>BFF 全称 <code>Backend For Frontend</code>，一般是指在前端与服务器端搭建一层由前端维护的 Node Server 服务。 其好处有：</p><ul><li><strong>数据处理</strong>。对数据进行校验、清洗及格式化，使得数据与前端更契合。</li><li><strong>数据聚合</strong>。后端无需处理大量的表连接工作，第三方接口聚合工作，业务逻辑简化为各个资源的增删改查，由 BFF 层聚合各个资源的数据，后端可集中处理性能问题、监控问题、消息队列等。</li><li><strong>权限前移</strong>。在 BFF 层统一认证鉴权，后端无需做权限校验，后端可直接部署在集群内网，无需向外网暴露服务，减少了后端复杂度。 其坏处是：</li><li>引入复杂度。新的 BFF 服务需要一套基础设施的支持，如日志、异常、部署、监控等。</li></ul><ol start="3"><li>设置 CORS 头部字段</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">Access</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Control</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Allow</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Origin</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">http</span><span style="color:#89DDFF;">:</span><span style="color:#676E95;font-style:italic;">//api.bob.com  // 允许跨域的源地址</span></span>
<span class="line"><span style="color:#BABED8;">Access</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Control</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Allow</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Methods</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> GET</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> POST</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> PUT </span><span style="color:#676E95;font-style:italic;">// 服务器支持的所有跨域请求的方法</span></span>
<span class="line"><span style="color:#BABED8;">Access</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Control</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Allow</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Headers</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> X</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Custom</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Header  </span><span style="color:#676E95;font-style:italic;">// 服务器支持的所有头信息字段</span></span>
<span class="line"><span style="color:#BABED8;">Access</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Control</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Allow</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Credentials</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#BABED8;">   </span><span style="color:#676E95;font-style:italic;">// 表示是否允许发送Cookie</span></span>
<span class="line"><span style="color:#BABED8;">Access</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Control</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Max</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Age</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1728000</span><span style="color:#BABED8;">  </span><span style="color:#676E95;font-style:italic;">// 用来指定本次预检请求的有效期，单位为秒</span></span></code></pre></div><h2 id="_5-cookie-和-localstorage" tabindex="-1">5. Cookie 和 localStorage <a class="header-anchor" href="#_5-cookie-和-localstorage" aria-label="Permalink to &quot;5. Cookie 和 localStorage&quot;">​</a></h2><h3 id="项目中的登录是用什么来存储-token-的" tabindex="-1">项目中的登录是用什么来存储 token 的 <a class="header-anchor" href="#项目中的登录是用什么来存储-token-的" aria-label="Permalink to &quot;项目中的登录是用什么来存储 token 的&quot;">​</a></h3><p>cookie</p><p>用户在浏览器输入账号密码，发送登录请求，服务端都到请求后，从数据库拿取数据来判断账号密码是否正确。在正确的情况下，服务器在向浏览器返回登录结果的时候，会生成一个 cookie，并且在 Http Response Header 中 Set-Cookie。这样，当浏览器再次向服务端发送请求时，都会同步的带上 cookie，cookie 会附带在每个 Http 请求上。</p><p>生成机制有两种：</p><ol><li><p>服务端生成，在 Http Response Header 中 Set-Cookie（GoCart 项目中使用的）</p></li><li><p>客户端生成，通过 document.cookie 设置</p></li></ol><h3 id="cookie-和-web-storage-localstorage、sessionstorage-的区别" tabindex="-1">cookie 和 Web Storage（localStorage、sessionStorage）的区别 <a class="header-anchor" href="#cookie-和-web-storage-localstorage、sessionstorage-的区别" aria-label="Permalink to &quot;cookie 和 Web Storage（localStorage、sessionStorage）的区别&quot;">​</a></h3><p>Cookie 设置初衷是用于<strong>维持 HTTP 状态</strong>，不用于存储数据，因此 cookie 有一下缺点：</p><ol><li>大小限制：每个 cookie 项只能存储 <strong>4K</strong> 数据</li><li>性能浪费：cookie 附带在 http 请求上，数据量过大，会导致每个 http 请求非常庞大，会很消耗流量和带宽。</li></ol><p>Web Storage <strong>专注存储</strong></p><p>localStorage</p><ul><li>特点：以域名维度，浏览器的<strong>持久化存储</strong>方案，在域名下一直存在，即使关闭会话窗口或浏览器，除非主动清理，否则永久存在；</li><li>大小：每个项可以存储 <strong>5M</strong> 的数据</li><li>接口：同步接口，会阻塞线程</li></ul><p>sessionStorage</p><ul><li>特点：以域名维度，浏览器基于<strong>会话级别的存储方案</strong>，它只有在当前会话窗口存储的数据才可以读取到，一旦关闭当前页面或新开一个窗口，之前存储的数据就获取不到了。刷新页面不会删除数据。</li><li>每个项可以存储 <strong>5M</strong> 的数据</li><li>接口：同步接口，阻塞线程</li></ul><h2 id="_6-react-常用的-hooks" tabindex="-1">6. React 常用的 Hooks <a class="header-anchor" href="#_6-react-常用的-hooks" aria-label="Permalink to &quot;6. React 常用的 Hooks&quot;">​</a></h2><ol><li>useState</li></ol><p>状态是变化的数据，是组件甚至前端应用的核心。useState 有传入值和函数两种参数，返回的 setState 也有传入值和函数两种参数。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 传入值</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#BABED8;">state</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> setState</span><span style="color:#89DDFF;">]</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">0</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 传入函数</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#BABED8;">num</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> setNum</span><span style="color:#89DDFF;">]</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">b</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">b</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">setState</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">setNum</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">state</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> state </span><span style="color:#89DDFF;">+</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 函数的参数是上一次的 state</span></span></code></pre></div><ol start="2"><li>useEffect</li></ol><p>副作用 effect 函数是在渲染之外额外执行的一些逻辑。它是根据第二个参数的依赖数组是否变化来决定是否执行 effect，可以返回一个清理函数，会在组件卸载前执行或每次使用更改的依赖性重新渲染之前运行。 执行时机：在渲染结束之后</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">useEffect</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">timer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">num</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">5000</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 清理函数</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">clearTimeout</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">timer</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#BABED8;"> [num])</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 如果不传第二个参数时，每次都会执行；传递第二个参数时，第二个参数有变化时执行</span></span></code></pre></div><ol start="3"><li>useLayoutEffect</li></ol><p>和 useEffect 差不多，但是 useEffect 的 effect 函数是异步执行的，所以可能中间有次渲染会闪屏。而 useLayoutEffect 是同步执行的，所以不会闪屏，但如果计算量大可能会导致掉帧，阻塞渲染。所以，仅当在浏览器渲染之前运行效果至关重要时才需要此功能，例如：在用户看到工具提示之前测量和定位工具提示。（只有在关键时刻需要在用户看到之前运行你的 Effect 时才需要使用它，例如，在显示提示工具提示之前测量和定位位置。）</p><ol start="4"><li>useInsertionEffect</li></ol><p>回调函数会在 commit 阶段的 Mutation 子阶段同步执行，与 useLayoutEffect 的区别在于执行的时候无法访问 DOM 的引用。这个 Hook 是专门为 CSS-in-JS 库插入全局的 style 元素而设计。</p><ol start="5"><li>useReducer</li></ol><p>封装一些修改状态的逻辑到 reducer，通过 action 触发。当修改深层对象的时候，创建新对象比较麻烦，可以结合 immer 来解决。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"></span></code></pre></div><ol start="6"><li>useRef</li></ol><p>可以保存 dom 引用或其他内容，通过<code>.current</code>来取，改变它的内容不会触发重新渲染。</p><ol start="7"><li>forwardRef + useImperativeHandle</li></ol><p>通过 forwardRef 可以从子组件转发 ref 到父组件。如果想自定义 ref 内容可以使用 useImperativeHandle 来实现。</p><ol start="8"><li>useContext</li></ol><p>跨层组件之间传递数据可以使用 Context。用 createContext 创建 context 对象，用 Provider 修改其中的值，函数组件使用 useContext 来取值，类组件使用 Consumer 来取值。</p><ol start="9"><li>memo + useMemo + useCallback</li></ol><p>memo 包裹的组件只有在 props 变化的时候才会重新渲染，useMemo、useCallback 可以防止 props 不必要的变化，两者一般是结合使用。不过当用来缓存计算结果等场景的时候，也可以单独使用 useMemo、useCallback。</p><h3 id="补充提问-说一说-useeffect-和-uselayouteffect-的区别" tabindex="-1">补充提问：说一说 useEffect 和 useLayoutEffect 的区别 <a class="header-anchor" href="#补充提问-说一说-useeffect-和-uselayouteffect-的区别" aria-label="Permalink to &quot;补充提问：说一说 useEffect 和 useLayoutEffect 的区别&quot;">​</a></h3><p>在 React 中，用于定义有副作用因变量的 Hook 有：</p><ul><li>useEffect：回调函数会在 commit 阶段完成后异步执行，所以不会阻塞视图渲染</li><li>useLayoutEffect：回调函数会在 commit 阶段的 Layout 子阶段同步执行，一般用于执行 DOM 相关的操作</li></ul><p>每一个 effect 会与当前 FC 其他的 effect 形成环状链表，连接方式为单向环状链表。 其中 useEffect 工作流程可以分为：</p><ul><li>声明阶段</li><li>调度阶段</li><li>执行阶段</li></ul><p>useLayoutEffect 的工作流程可以分为：</p><ul><li>声明阶段</li><li>执行阶段</li></ul><p>之所以 useEffect 会比 useLayoutEffect 多一个阶段，就是因为 useEffect 的回调函数会在 commit 阶段完成后异步执行，因此需要经历调度阶段。</p><h2 id="_7-虚拟-dom" tabindex="-1">7. 虚拟 DOM <a class="header-anchor" href="#_7-虚拟-dom" aria-label="Permalink to &quot;7. 虚拟 DOM&quot;">​</a></h2><p>虚拟 DOM 最早是由 React 团队提出来的，这是一种编程思想，指的是针对真实 UI DOM 的一种描述能力。 在 React 中，使用了 JS 对象来描述真实的 DOM 结构。虚拟 DOM 和 JS 对象之间的关系：前者是一种思想，后者是一种思想的具体实现。</p><h3 id="虚拟-dom-的优势" tabindex="-1">虚拟 DOM 的优势 <a class="header-anchor" href="#虚拟-dom-的优势" aria-label="Permalink to &quot;虚拟 DOM 的优势&quot;">​</a></h3><p>使用虚拟 DOM 主要有两个方面的优势：</p><ol><li>相较于 DOM 的体积优势和速度优势</li><li>多平台渲染的抽象能力</li></ol><h4 id="_1-相较于-dom-的体积优势和速度优势" tabindex="-1">1. 相较于 DOM 的体积优势和速度优势 <a class="header-anchor" href="#_1-相较于-dom-的体积优势和速度优势" aria-label="Permalink to &quot;1. 相较于 DOM 的体积优势和速度优势&quot;">​</a></h4><ul><li>JS 层面的计算速度要比 DOM 层面的计算快得多 <ul><li>DOM 对象最终被浏览器渲染出来之前，浏览器会有很多工作要做（浏览器渲染原理）</li><li>DOM 对象上面的属性非常多</li></ul></li><li>虚拟 DOM 发挥优势的时机主要体现在更新阶段，相比较 innerHTML 要将已有的 DOM 节点全部销毁，虚拟 DOM 能够做到针对 DOM 节点做最小程度的修改</li></ul><h4 id="_2-多平台渲染的抽象能力" tabindex="-1">2. 多平台渲染的抽象能力 <a class="header-anchor" href="#_2-多平台渲染的抽象能力" aria-label="Permalink to &quot;2. 多平台渲染的抽象能力&quot;">​</a></h4><ul><li>浏览器、Node.js 宿主环境使用 ReactDOM 包</li><li>Native 宿主环境使用 ReactNative 包</li><li>Canvas、SVG 或者 VML（IE8）宿主环境使用 ReactArt 包</li><li>ReactTest 包用于渲染出 JS 对象，可以很方便的测试“不隶属于任何宿主环境的通用功能”</li></ul><p>在 React 中通过 JSX 来描述 UI，JSX 仅仅是一个语法糖，会被 Babel 编译为 createElement 方法的调用。该方法调用之后会返回一个 JS 对象，该对象就是虚拟 DOM 对象，官方更倾向于称之为一个 React 元素。</p><h2 id="_8-react-diff-算法" tabindex="-1">8. React diff 算法 <a class="header-anchor" href="#_8-react-diff-算法" aria-label="Permalink to &quot;8. React diff 算法&quot;">​</a></h2><p>diff 计算发生在更新阶段，当第一次渲染完成后，就会产生 Fiber 树，再次渲染的时候（更新），就会拿新的 JSX 对象（vdom）和旧的 FiberNode 节点进行一个对比，再决定如何来产生新的 FiberNode，它的目标是尽可能的复用已有的 Fiber 节点。这个就是 diff 算法。</p><p>在 React 中整个 diff 分为单节点 diff 和多节点 diff。 所谓单节点是指新的节点为单一节点，但是旧节点的数量是不一定的。 单节点 diff 是否能够复用遵循如下的顺序：</p><ol><li>判断 key 是否相同</li></ol><ul><li>如果更新前后均未设置 key，则 key 均为 null，也属于相同的情况</li><li>如果 key 相同，进入步骤 2</li><li>如果 key 不同，则无需判断 type，结果为不能复用（有兄弟节点还会去遍历兄弟节点）</li></ul><ol start="2"><li>如果 key 相同，再判断 type 是否相同</li></ol><ul><li>如果 type 相同，那么就复用</li><li>如果 type 不同，则无法复用（并且兄弟节点也一并标记为删除）</li></ul><p>多节点 diff 会分为两轮遍历： 第一轮遍历会从前往后进行遍历，存在以下三种情况：</p><ul><li>如果新旧子节点的 key 和 type 都相同，说明可以复用</li><li>如果新旧子节点的 key 相同，但是 type 不同，这个时候就会根据 ReactElement 来生成一个全新的 fiber，旧的 fiber 被放入到 deletions 数组里面，回头统一删除。但是注意，此时遍历遍历并不会终止</li><li>如果新旧子节点的 key 和 type 都不相同，结束遍历</li></ul><p>如果第一轮遍历被提前终止了，那么意味着还有新的 JSX 元素或者旧的 FiberNode 没有被遍历，因此会采用第二轮遍历去处理。 第二轮遍历会遇到三种情况：</p><ul><li>只剩下旧子节点：将旧的子节点添加到 deletions 数组里面直接删除（删除的情况）</li><li>只剩下新的 JSX 元素：根据 ReactElement 元素来创建 FiberNode 节点（新增的情况）</li><li>新旧子节点都有剩余：会将剩余的 FiberNode 节点放入一个 map 里面，遍历剩余的新的 JSX 元素，然后从 map 中去寻找能够复用的 FiberNode 节点，如果能够找到，就拿来复用（移动的情况） 如果不能找到，就新增。然后如果剩余的 JSX 元素都遍历完了，map 结构中还有剩余的 Fiber 节点，就将这些 Fiber 节点添加到 deletions 数组里面，之后统一做删除操作。</li></ul><p>整个 diff 算法最核心的就是两个字“复用”。</p><p>React 不使用双端 diff 的原因： 由于双端 diff 需要向前查找节点，但每个 FiberNode 节点上都没有反向指针，即前一个 FiberNode 通过 sibling 属性指向后一个 FiberNode，只能从前往后遍历，而不能反过来，因此该算法无法通过双端搜索来进行优化。 React 想看下现在用这种方式能走多远，如果这种方式不理想，以后再考虑实现双端 diff。React 认为对于列表反转和需要进行双端搜索的场景是少见的，所以在这一版的实现中，先不对 bad case 做额外的优化。</p>`,121),e=[p];function t(c,r,y,F,i,D){return a(),l("div",null,e)}const E=s(o,[["render",t]]);export{A as __pageData,E as default};
