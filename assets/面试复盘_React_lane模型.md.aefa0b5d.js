import{_ as s,o as n,c as a,V as l}from"./chunks/framework.bd00fe0c.js";const E=JSON.parse('{"title":"lane 模型","description":"","frontmatter":{},"headers":[],"relativePath":"面试复盘/React/lane模型.md","filePath":"面试复盘/React/lane模型.md","lastUpdated":1710918713000}'),p={name:"面试复盘/React/lane模型.md"},o=l(`<h1 id="lane-模型" tabindex="-1">lane 模型 <a class="header-anchor" href="#lane-模型" aria-label="Permalink to &quot;lane 模型&quot;">​</a></h1><blockquote><p>面试题：是否了解过 React 中的 lane 模型？为什么要从之前的 expirationTime 模型转换为 lane 模型？</p></blockquote><h2 id="react-和-scheduler-优先级的介绍" tabindex="-1">React 和 Scheduler 优先级的介绍 <a class="header-anchor" href="#react-和-scheduler-优先级的介绍" aria-label="Permalink to &quot;React 和 Scheduler 优先级的介绍&quot;">​</a></h2><p>之前我们已经介绍过 Scheduler，React 团队是打算将 Scheduler 进行独立发布。</p><p>在 React 内部，还会有一个粒度更细的优先级算法，这个就是 lane 模型。</p><p>接下来我们来看一下两套优先级模型的一个转换。</p><p>在 Scheduler 内部，拥有 5 种优先级：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> NoPriority </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> ImmediatePriority </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> UserBlockingPriority </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> NormalPriority </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">3</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> LowPriority </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">4</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> IdlePriority </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">5</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>作为一个独立的包，需要考虑到通用性，Scheduler 和 React 的优先级并不共通，在 React 内部，有四种优先级，如下四种：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> DiscreteEventPriority</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">EventPriority</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> SyncLane</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> ContinuousEventPriority</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">EventPriority</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> InputContinuousLane</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> DefaultEventPriority</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">EventPriority</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> DefaultLane</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> IdleEventPriority</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">EventPriority</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> IdleLane</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>由于 React 中不同的交互对应的事件回调中产生的 update 会有不同的优先级，因此优先级与事件有关，因此在 React 内部的优先级也被称之为 EventPriority，各种优先级的含义如下：</p><ul><li>DiscreteEventPriority：对应离散事件优先级，例如 click、input、focus、blur、touchstart 等事件都是离散触发的</li><li>ContinuousEventPriority：对应连续事件的优先级，例如 drag、mousemove、scroll、touchmove 等事件都是连续触发的</li><li>DefaultEventPriority：对应默认的优先级，例如通过计时器周期性触发更新，这种情况下产生的 update 不属于交互产生 update，所以优先级是默认的优先级</li><li>IdleEventPriority：对应空闲情况的优先级</li></ul><p>在上面的代码中，我们还可以观察出一件事情，不同级别的 EventPriority 对应的是不同的 lane</p><p>既然 React 与 Scheduler 优先级不互通，那么这里就会涉及到一个转换的问题，这里分为：</p><ul><li>React 优先级转为 Scheduler 的优先级</li><li>Scheduler 的优先级转为 React 的优先级</li></ul><p><strong>React 优先级转为 Scheduler 的优先级</strong></p><p>整体会经历两次转换：</p><ul><li>首先是将 lanes 转为 EventPriority，涉及到的方法如下：</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">lanesToEventPriority</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">lanes</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Lanes</span><span style="color:#89DDFF;">):</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">EventPriority</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// getHighestPriorityLane 方法用于分离出优先级最高的 lane</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">lane</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">getHighestPriorityLane</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">lanes</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!</span><span style="color:#82AAFF;">isHigherEventPriority</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">DiscreteEventPriority</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">lane</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">DiscreteEventPriority</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">!</span><span style="color:#82AAFF;">isHigherEventPriority</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">ContinuousEventPriority</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">lane</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">ContinuousEventPriority</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#82AAFF;">includesNonIdleWork</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">lane</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">DefaultEventPriority</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">IdleEventPriority</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><ul><li>将 EventPriority 转换为 Scheduler 的优先级，方法如下：</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// ...</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> schedulerPriorityLevel</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">switch</span><span style="color:#BABED8;"> (</span><span style="color:#82AAFF;">lanesToEventPriority</span><span style="color:#BABED8;">(nextLanes)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#BABED8;"> DiscreteEventPriority</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#BABED8;">        schedulerPriorityLevel </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> ImmediateSchedulerPriority</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">break</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#BABED8;"> ContinuousEventPriority</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#BABED8;">        schedulerPriorityLevel </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> UserBlockingSchedulerPriority</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">break</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#BABED8;"> DefaultEventPriority</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#BABED8;">        schedulerPriorityLevel </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> NormalSchedulerPriority</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">break</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#BABED8;"> IdleEventPriority</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#BABED8;">        schedulerPriorityLevel </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> IdleSchedulerPriority</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">break</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#BABED8;">        schedulerPriorityLevel </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> NormalSchedulerPriority</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">break</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// ...</span></span></code></pre></div><p>举一个例子，假设现在有一个点击事件，在 onClick 中对应有一个回调函数来触发更新，该更新属于 DiscreteEventPriority，经过上面的两套转换规则进行转换之后，最终得到的 Scheduler 对应的优先级就是 ImmediateSchedulerPriority</p><p><strong>Scheduler 的优先级转为 React 的优先级</strong></p><p>转换相关的代码如下：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> schedulerPriority </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">getCurrentSchedulerPriorityLevel</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">switch</span><span style="color:#BABED8;"> (schedulerPriority) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#BABED8;"> ImmediateSchedulerPriority</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#BABED8;"> DiscreteEventPriority</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#BABED8;"> UserBlockingSchedulerPriority</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#BABED8;"> ContinuousEventPriority</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#BABED8;"> NormalSchedulerPriority</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#BABED8;"> LowSchedulerPriority</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#BABED8;"> DefaultEventPriority</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#BABED8;"> IdleSchedulerPriority</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#BABED8;"> IdleEventPriority</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#BABED8;"> DefaultEventPriority</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>这里会涉及到一个问题，在同一时间可能存在很多的更新，究竟先去更新哪一个？</p><ul><li>从众多的有优先级的 update 中选出一个优先级最高的</li><li>表达批的概念</li></ul><p>React 在表达方式上面实际上经历了两次迭代：</p><ul><li>基于 expirationTime 的算法</li><li>基于 lane 的算法</li></ul><h2 id="expirationtime-模型" tabindex="-1">expirationTime 模型 <a class="header-anchor" href="#expirationtime-模型" aria-label="Permalink to &quot;expirationTime 模型&quot;">​</a></h2><p>React 早期采用的就是 expirationTime 的算法，这一点和 Scheduler 里面的设计是一致的。</p><p>在 Scheduler 中，设计了 5 种优先级，不同的优先级会对应不同的 timeout，最终会对应不同的 expirationTime，然后 task 根据 expirationTime 来进行任务的排序。</p><p>早期的时候在 React 中延续了这种设计，update 的优先级与触发事件的当前时间以及优先级对应的延迟时间相关，这样的算法实际上是比较简单易懂的，每当进入 schedule 的时候，就会选出优先级最高的 update 进行一个调度。</p><p>但是这种算法在表示“批”的概念上不够灵活。</p><p>在基于 expirationTime 模型的算法中，有如下的表达：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> isUpdateIncludedInBatch </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> priorityOfUpdate </span><span style="color:#89DDFF;">&gt;=</span><span style="color:#BABED8;"> priorityOfBatch</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>priorityOfUpdate 表示的是当前 update 的优先级，priorityOfBatch 代表的是批对应的优先级下限，也就是说，当前的 update 只要大于等于 priorityOfBatch，就会被划分为同一批：</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2023-03-16-032346.png" alt="image-20230316112346465" style="zoom:50%;"><p>但是此时就会存在一个问题，如何将某一范围的某几个优先级划为同一批？</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2023-03-16-032601.png" alt="image-20230316112601346" style="zoom:50%;"><p>在上图中，我们想要将 u1、u2、u3 和 u4 划分为同一批，但是以前的 expirationTime 模型是无法做到的。</p><p>究其原因，是因为 expirationTime 模型优先级算法耦合了“优先级”和“批”的概念，限制了模型的表达能力。优先级算法的本质是为 update 进行一个排序，但是 expirationTime 模型在完成排序的同时还默认的划定了“批”。</p><h2 id="lane-模型-1" tabindex="-1">lane 模型 <a class="header-anchor" href="#lane-模型-1" aria-label="Permalink to &quot;lane 模型&quot;">​</a></h2><p>因此，基于上述的原因，React 中引入了 lane 模型。</p><p>不管新引入什么模型，比如要保证以下两个问题得到解决：</p><ul><li>以优先级为依据，对 update 进行一个排序</li><li>表达批的概念</li></ul><p>针对第一个问题，lane 模型中设置了很多的 lane，每一个 lane 实际上是一个二进制数，通过二进制来表达优先级，越低的位代表越高的优先级，例如：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> SyncLane</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Lane</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">/*                        */</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0b0000000000000000000000000000001</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> InputContinuousLane</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Lane</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">/*             */</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0b0000000000000000000000000000100</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> DefaultLane</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Lane</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">/*                     */</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0b0000000000000000000000000010000</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> IdleLane</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Lane</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">/*                        */</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0b0100000000000000000000000000000</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> OffscreenLane</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">Lane</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">/*                   */</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0b1000000000000000000000000000000</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>在上面的代码中，SyncLane 是最高优先级，OffscreenLane 是最低优先级。</p><p>对于第二个问题，lane 模型能够非常灵活的表达批的概念：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 要使用的批</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#BABED8;"> batch </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// laneA 和 laneB。是不相邻的优先级</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> laneA </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0b0000000000000000000000001000000</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> laneB </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">0b0000000000000000000000000000001</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 将 laneA 纳入批中</span></span>
<span class="line"><span style="color:#BABED8;">batch </span><span style="color:#89DDFF;">|=</span><span style="color:#BABED8;"> laneA</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 将 laneB 纳入批中</span></span>
<span class="line"><span style="color:#BABED8;">batch </span><span style="color:#89DDFF;">|=</span><span style="color:#BABED8;"> laneB</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h2 id="真题解答" tabindex="-1">真题解答 <a class="header-anchor" href="#真题解答" aria-label="Permalink to &quot;真题解答&quot;">​</a></h2><blockquote><p>题目：是否了解过 React 中的 lane 模型？为什么要从之前的 expirationTime 模型转换为 lane 模型？</p><p>参考答案：</p><p>在 React 中有一套独立的粒度更细的优先级算法，这就是 lane 模型。</p><p>这是一个基于位运算的算法，每一个 lane 是一个 32 bit Integer，不同的优先级对应了不同的 lane，越低的位代表越高的优先级。</p><p>早期的 React 并没有使用 lane 模型，而是采用的的基于 expirationTime 模型的算法，但是这种算法耦合了“优先级”和“批”这两个概念，限制了模型的表达能力。优先级算法的本质是“为 update 排序”，但 expirationTime 模型在完成排序的同时还默认的划定了“批”。</p><p>使用 lane 模型就不存在这个问题，因为是基于位运算，所以在批的划分上会更加的灵活。</p></blockquote>`,53),e=[o];function t(c,r,y,i,D,F){return n(),a("div",null,e)}const A=s(p,[["render",t]]);export{E as __pageData,A as default};
