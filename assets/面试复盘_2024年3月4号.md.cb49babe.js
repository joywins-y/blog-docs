import{_ as s,o as a,c as n,V as l}from"./chunks/framework.bd00fe0c.js";const A=JSON.parse('{"title":"3 月 4 号面试题","description":"","frontmatter":{},"headers":[],"relativePath":"面试复盘/2024年3月4号.md","filePath":"面试复盘/2024年3月4号.md","lastUpdated":1711897950000}'),o={name:"面试复盘/2024年3月4号.md"},p=l(`<h1 id="_3-月-4-号面试题" tabindex="-1">3 月 4 号面试题 <a class="header-anchor" href="#_3-月-4-号面试题" aria-label="Permalink to &quot;3 月 4 号面试题&quot;">​</a></h1><h2 id="_1-前端判断数据类型的方法有哪些" tabindex="-1">1. 前端判断数据类型的方法有哪些 <a class="header-anchor" href="#_1-前端判断数据类型的方法有哪些" aria-label="Permalink to &quot;1. 前端判断数据类型的方法有哪些&quot;">​</a></h2><p>JS 数据类型：</p><p>string、number、boolean、undefined、null、symbol、bigint、object</p><p>7 种基本数据类型：string、number、boolean、undefined、null、symbol、bigint，存储在栈中，存取方式是先进后出。</p><p>引用数据类型 对象（Object）类型包括：数组（Array）、函数（Function）、还有两个特殊的对象：正则（RegExp）和日期（Date），存储在堆中，按优先级排序，优先级可以按照大小来规定。</p><h3 id="_1-typeof" tabindex="-1">1. typeof <a class="header-anchor" href="#_1-typeof" aria-label="Permalink to &quot;1. typeof&quot;">​</a></h3><p>可以用来确定一个值的基本数据类型，返回一个表示数据类型的字符串。数组、对象、null 都会判断为 object，其他类型正确判断。</p><p><strong>注意</strong>：<code>typeof null</code> 返回“object”是历史遗留问题。</p><h3 id="_2-instanceof" tabindex="-1">2. instanceof <a class="header-anchor" href="#_2-instanceof" aria-label="Permalink to &quot;2. instanceof&quot;">​</a></h3><p>只能正确判断引用数据类型，不能判断基本数据类型。</p><p>instanceof 可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</p><h3 id="_3-constructor" tabindex="-1">3. constructor <a class="header-anchor" href="#_3-constructor" aria-label="Permalink to &quot;3. constructor&quot;">​</a></h3><p>constructor 有两个作用：一是判断数据类型（可以判断全部类型），二是对象实例通过 constructor 对象访问它的构造函数。</p><p>需要注意的是，如果创建一个对象来改变它的原型，constructor 就不能用来判断数据类型了。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> Fn </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">Fn</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">prototype </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Array</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> f </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">Fn</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(Fn</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">constructor </span><span style="color:#89DDFF;">===</span><span style="color:#BABED8;"> Function)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(f</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">constructor </span><span style="color:#89DDFF;">===</span><span style="color:#BABED8;"> Fn)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// false</span></span>
<span class="line"><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#BABED8;">(f</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">constructor </span><span style="color:#89DDFF;">===</span><span style="color:#BABED8;"> Array)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// true</span></span></code></pre></div><p>解析：<code>f.constructor</code> 也即<code>f.__proto__.constructor</code>， <strong>实例对象的<code>__proto__</code>指向其构造函数的原型对象 prototype</strong>。 故<code>f.__proto__</code>等价于 <code>Fn.prototype</code>， 所以<code>f.__proto__.constructor === Fn.prototype.constructor</code> <code>Fn.prototype</code>是<code>Array</code>的实例对象 实例对象的<code>constructor</code>属性指向构造函数本身 所以<code>Fn.prototype.constructor === Array</code></p><p>其实就是<code>new Array()</code>得到的对象覆盖了原来的<code>Fn.prototype</code>，所以<code>Fn.prototype.constructor</code>不再指向<code>Fn</code>，而是指向了<code>Array</code></p><h3 id="_4-object-prototype-tostring-call" tabindex="-1">4. Object.prototype.toString.call() <a class="header-anchor" href="#_4-object-prototype-tostring-call" aria-label="Permalink to &quot;4. Object.prototype.toString.call()&quot;">​</a></h3><p>Object.prototype.toString.call() 是使用 Object 对象的原型方法 toString 来判断数据类型</p><p>扩展：同样是检测对象 obj 调用 toString 方法，obj.toString() 的结果和 Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p><p>这是因为 toString 是 Object 的原型方法，而<strong>Array、function 等类型作为 Object 的实例，都重写了 toString 方法</strong>。不同的对象类型调用 toString 方法时，根据原型链的知识，调用的是对应的重写之后的 toString 方法（function 类型返回内容为函数体的字符串，Array 类型返回元素组成的字符串），而不会去调用 Object 上原型 toString 方法（返回对象的具体类型），所以采用 obj.toString()不能得到其对象类型，只能将 obj 转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用 Object 原型上的 toString 方法。</p><h3 id="补充提问-typeof-和-instanceof-的区别" tabindex="-1">补充提问：typeof 和 instanceof 的区别 <a class="header-anchor" href="#补充提问-typeof-和-instanceof-的区别" aria-label="Permalink to &quot;补充提问：typeof 和 instanceof 的区别&quot;">​</a></h3><ol><li><p>返回值类型不一样：typeof 返回一个表示数据类型的字符串，instanceof 返回一个布尔值，表示是否为指定类的实例。</p></li><li><p>判断范围和精确性不一样：typeof 对基本数据类型判断较精确，但是对引用类型无法进一步区分。对于对象、数组、null 会判断成 object。instanceof 判断引用类型更精确，无法判断基本数据类型。instanceof 是通过指定类实例来判断的，但是基本数据类型是没有对象的，无法通过类实例来进行判断。因为实例是一个对象或函数创建的，是引用类型。</p></li></ol><h3 id="补充提问-typeof-为什么判断-null-时会判断成-object-自己补充" tabindex="-1">补充提问：typeof 为什么判断 null 时会判断成 object（自己补充） <a class="header-anchor" href="#补充提问-typeof-为什么判断-null-时会判断成-object-自己补充" aria-label="Permalink to &quot;补充提问：typeof 为什么判断 null 时会判断成 object（自己补充）&quot;">​</a></h3><p>在 JS 第一个版本之后，所有值都存储在 32 位的单元中，每个单元包含一个小的**类型标签（1-3 bits）**以及当前要存储值的真实数据。类型标签存储在每个单位的低位中，共有 5 种数据类型：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#F78C6C;">000</span><span style="color:#BABED8;">: object     </span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;"> 当前存储的数据指向一个对象</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">: int        </span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;"> 当前存储的数据是一个 </span><span style="color:#F78C6C;">31</span><span style="color:#BABED8;"> 位的有符号整数</span></span>
<span class="line"><span style="color:#F78C6C;">010</span><span style="color:#BABED8;">: double     </span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;"> 当前存储的数据指向一个双精度的浮点数</span></span>
<span class="line"><span style="color:#F78C6C;">100</span><span style="color:#BABED8;">: string     </span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;"> 当前存储的数据指向一个字符串</span></span>
<span class="line"><span style="color:#F78C6C;">110</span><span style="color:#BABED8;">: boolean    </span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;"> 当前存储的数据是布尔值</span></span></code></pre></div><p>如果最低位是 1，则类型标签标志位的长度只有 1 位；如果最低位是 0，则类型标签标志位的长度占 3 位，为存储其他四种数据类型提供了额外两个 bit 的长度。</p><p>有两种特殊数据类型：</p><ul><li>undefined 的值是(-2^30)(一个超出整数范围的数字)</li><li>null 的值是机器码 NULL 指针（null 指针的值全是 0）</li></ul><p>那么也就是说，null 的 类型标签也是 000，和 Object 的类型标签一样，所以会被判定为 Object。</p><h2 id="_2-防抖和节流" tabindex="-1">2. 防抖和节流 <a class="header-anchor" href="#_2-防抖和节流" aria-label="Permalink to &quot;2. 防抖和节流&quot;">​</a></h2><h3 id="防抖" tabindex="-1">防抖 <a class="header-anchor" href="#防抖" aria-label="Permalink to &quot;防抖&quot;">​</a></h3><p>防抖是指用户事件被触发 n 秒后执行回调逻辑，如果在这 n 秒内，事件再次被触发，则重新计时。换言之，程序只执行最后一次触发事件，以此来优化性能。</p><p>应用场景：</p><ul><li>搜索框输入的时候，用户输入 1-9，不加防抖页面会渲染 9 次。加上防抖之后，页面渲染一次即可。</li><li>防止多次提交按钮，只执行最后一次提交</li></ul><p>实现代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> debounce </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">fn</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">delay</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">timer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(...</span><span style="color:#BABED8;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">clearTimeout</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">timer</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 先清除定时器</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">timer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 然后设置定时器，执行回调逻辑</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#82AAFF;">fn</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">args</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">delay</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><h3 id="节流" tabindex="-1">节流 <a class="header-anchor" href="#节流" aria-label="Permalink to &quot;节流&quot;">​</a></h3><p>节流是指当用户遇到连续用户事件时，以 n 秒为间隔进行阻断，目的是减少同一时间段内连续事件的触发频率，以此来提升性能。</p><p>应用场景：</p><ul><li>拖拽场景：固定时间内执行一次，防止超高频次触发位置变动</li><li>缩放场景：监控浏览器 resize（调整浏览器窗口大小，触发 resize 事件）</li><li>动画场景：避免短时间内多次触发动画引发性能问题</li></ul><p>实现代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> trottle </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">fn</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">delay</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">timer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(...</span><span style="color:#BABED8;font-style:italic;">args</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">timer</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// timer 存在，说明已经执行了回调函数，暂时不再执行</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">timer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">// 先执行回调逻辑，再清除定时器</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#82AAFF;">fn</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">args</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#82AAFF;">clearTimeout</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">timer</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#BABED8;">timer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">delay</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><h2 id="_3-深拷贝" tabindex="-1">3. 深拷贝 <a class="header-anchor" href="#_3-深拷贝" aria-label="Permalink to &quot;3. 深拷贝&quot;">​</a></h2><ol><li>JSON.parse(JSON.stringify(obj)) <ul><li>遇到 undefined 和函数会报错；</li><li>对象里面 key 为 Symbol、值为 undefined、值为函数，都会被忽略；</li><li>对象里面值为 NaN、值为 Infinity 会变成 null。</li></ul></li><li>js 工具库 lodash.cloneDeep(obj)</li><li>递归复制</li></ol><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> deepClone </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">obj</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#89DDFF;">typeof</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">obj</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">object</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">||</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">obj</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">===</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">obj</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">result</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">Array</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isArray</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">obj</span><span style="color:#F07178;">)) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">result</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> []</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#F07178;"> (</span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">i</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">obj</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">length</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">i</span><span style="color:#89DDFF;">++</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#BABED8;">result</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#82AAFF;">deepClone</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">obj</span><span style="color:#F07178;">[</span><span style="color:#BABED8;">i</span><span style="color:#F07178;">]))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">obj</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">instanceof</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">Set</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">result</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Set</span><span style="color:#F07178;">([</span><span style="color:#89DDFF;">...</span><span style="color:#BABED8;">obj</span><span style="color:#F07178;">])</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">obj</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">instanceof</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">Map</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">result</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">new</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">Map</span><span style="color:#F07178;">([</span><span style="color:#89DDFF;">...</span><span style="color:#BABED8;">obj</span><span style="color:#F07178;">])</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">result</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{};</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">Reflect</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">ownKeys</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">obj</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">forEach</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">key</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            </span><span style="color:#BABED8;">result</span><span style="color:#F07178;">[</span><span style="color:#BABED8;">key</span><span style="color:#F07178;">] </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">deepClone</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">obj</span><span style="color:#F07178;">[</span><span style="color:#BABED8;">key</span><span style="color:#F07178;">])</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">result</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><ol start="4"><li>Object.assign({}, obj) <ul><li>只深拷贝第一层</li></ul></li></ol><blockquote><p>扩展： JSON.parse 和 JSON.stringify 还可以用于删除对象属性</p></blockquote><h2 id="_4-前端跨域" tabindex="-1">4. 前端跨域 <a class="header-anchor" href="#_4-前端跨域" aria-label="Permalink to &quot;4. 前端跨域&quot;">​</a></h2><h3 id="什么时候发生跨域" tabindex="-1">什么时候发生跨域 <a class="header-anchor" href="#什么时候发生跨域" aria-label="Permalink to &quot;什么时候发生跨域&quot;">​</a></h3><p>跨域是由于浏览器的同源策略所导致的，是发生在<strong>页面</strong>到<strong>服务端</strong>请求的过程中</p><h3 id="怎么解决跨域" tabindex="-1">怎么解决跨域 <a class="header-anchor" href="#怎么解决跨域" aria-label="Permalink to &quot;怎么解决跨域&quot;">​</a></h3><h4 id="_1-nginx-反向代理-可以使用-docker-开镜像" tabindex="-1">1. Nginx 反向代理（可以使用 docker 开镜像） <a class="header-anchor" href="#_1-nginx-反向代理-可以使用-docker-开镜像" aria-label="Permalink to &quot;1. Nginx 反向代理（可以使用 docker 开镜像）&quot;">​</a></h4><blockquote><p>使用 Nginx 充当代理服务器，分发请求到目标服务器</p></blockquote><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">server </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">listen</span><span style="color:#F07178;">      </span><span style="color:#F78C6C;">5000</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">server_name</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">127.0</span><span style="color:#89DDFF;">.</span><span style="color:#F78C6C;">0.1</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">location</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">/</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_pass</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">http</span><span style="color:#89DDFF;">:</span><span style="color:#676E95;font-style:italic;">//127.0.0.1:3000;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_set_header</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">Host</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">$host</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_set_header</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">X</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Real</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">IP</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">$remote_addr</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_set_header</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">X</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Forwarded</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">For</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">$proxy_add_x_forwarded_for</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">location</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">/</span><span style="color:#BABED8;">api</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_pass</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">http</span><span style="color:#89DDFF;">:</span><span style="color:#676E95;font-style:italic;">//127.0.0.1:4000;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_set_header</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">Host</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">$host</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_set_header</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">X</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Real</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">IP</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">$remote_addr</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">proxy_set_header</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">X</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Forwarded</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">For</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">$proxy_add_x_forwarded_for</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h4 id="_2-搭建-bff-层来解决跨域问题-node-环境" tabindex="-1">2. 搭建 BFF 层来解决跨域问题（Node 环境） <a class="header-anchor" href="#_2-搭建-bff-层来解决跨域问题-node-环境" aria-label="Permalink to &quot;2. 搭建 BFF 层来解决跨域问题（Node 环境）&quot;">​</a></h4><blockquote><p>Node.js 同域部署页面，搭建 BFF 层，服务对服务请求</p></blockquote><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> KoaRouter </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">require</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">koa-router</span><span style="color:#89DDFF;">&#39;</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> router </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">new</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">KoaROuter</span><span style="color:#BABED8;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">router</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">post</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">/api/task</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">async</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">ctx</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">next</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">res</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">axios</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">post</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">http://127.0.0.1:4000/api/task</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#BABED8;">ctx</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">body</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">res</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">data</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#BABED8;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">use</span><span style="color:#BABED8;">(router</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">routes</span><span style="color:#BABED8;">())</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">app</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">use</span><span style="color:#BABED8;">(router</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">allowedMethos</span><span style="color:#BABED8;">())</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h5 id="延伸问题-引入-bff-层有什么好处" tabindex="-1">延伸问题：引入 BFF 层有什么好处 <a class="header-anchor" href="#延伸问题-引入-bff-层有什么好处" aria-label="Permalink to &quot;延伸问题：引入 BFF 层有什么好处&quot;">​</a></h5><p>BFF 全称 <code>Backend For Frontend</code>，一般是指在前端与服务器端搭建一层由前端维护的 Node Server 服务。</p><p>其好处有：</p><ul><li><strong>数据处理</strong>。对数据进行校验、清洗及格式化，使得数据与前端更契合。</li><li><strong>数据聚合</strong>。后端无需处理大量的表连接工作，第三方接口聚合工作，业务逻辑简化为各个资源的增删改查，由 BFF 层聚合各个资源的数据，后端可集中处理性能问题、监控问题、消息队列等。</li><li><strong>权限前移</strong>。在 BFF 层统一认证鉴权，后端无需做权限校验，后端可直接部署在集群内网，无需向外网暴露服务，减少了后端复杂度。</li></ul><p>其坏处是：</p><ul><li>引入复杂度。新的 BFF 服务需要一套基础设施的支持，如日志、异常、部署、监控等。</li></ul><h4 id="_3-设置-cors-头部字段" tabindex="-1">3. 设置 CORS 头部字段 <a class="header-anchor" href="#_3-设置-cors-头部字段" aria-label="Permalink to &quot;3. 设置 CORS 头部字段&quot;">​</a></h4><blockquote><p>服务器端配置 CORS 策略，可以允许指定源（协议、域名、端口）的请求，设置<code>Access-Control-Allow-Origin</code></p></blockquote><p>CORS 是一种基于 HTTP 头的跨域解决方案，它允许服务器指定哪些域可以访问其资源。通过在响应头中添加 Access-Control-Allow-Origin 标签，服务器可以允许指定域的请求访问其资源。CORS 支持多种 HTTP 请求方法，包括 GET、POST、PUT、DELETE 等。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">Access</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Control</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Allow</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Origin</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">http</span><span style="color:#89DDFF;">:</span><span style="color:#676E95;font-style:italic;">//api.bob.com  // 允许跨域的源地址</span></span>
<span class="line"><span style="color:#BABED8;">Access</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Control</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Allow</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Methods</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> GET</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> POST</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> PUT </span><span style="color:#676E95;font-style:italic;">// 服务器支持的所有跨域请求的方法</span></span>
<span class="line"><span style="color:#BABED8;">Access</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Control</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Allow</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Headers</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> X</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Custom</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Header  </span><span style="color:#676E95;font-style:italic;">// 服务器支持的所有头信息字段</span></span>
<span class="line"><span style="color:#BABED8;">Access</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Control</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Allow</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Credentials</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FF9CAC;">true</span><span style="color:#BABED8;">   </span><span style="color:#676E95;font-style:italic;">// 表示是否允许发送Cookie</span></span>
<span class="line"><span style="color:#BABED8;">Access</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Control</span><span style="color:#89DDFF;">-</span><span style="color:#BABED8;">Max</span><span style="color:#89DDFF;">-</span><span style="color:#FFCB6B;">Age</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1728000</span><span style="color:#BABED8;">  </span><span style="color:#676E95;font-style:italic;">// 用来指定本次预检请求的有效期，单位为秒</span></span></code></pre></div><h4 id="_4-iframe-通讯" tabindex="-1">4. iframe 通讯 <a class="header-anchor" href="#_4-iframe-通讯" aria-label="Permalink to &quot;4. iframe 通讯&quot;">​</a></h4><blockquote><p>通过在主页嵌入一个隐藏的 iframe，将目标页面加载到 iframe 中，并通过在主页面和 iframe 页面之间使用 <code>postMessage()</code> 方法进行消息传递，从而实现跨域的数据交换。</p></blockquote><h2 id="_5-cookie-和-localstorage" tabindex="-1">5. Cookie 和 localStorage <a class="header-anchor" href="#_5-cookie-和-localstorage" aria-label="Permalink to &quot;5. Cookie 和 localStorage&quot;">​</a></h2><h3 id="项目中的登录是用什么来存储-token-的" tabindex="-1">项目中的登录是用什么来存储 token 的 <a class="header-anchor" href="#项目中的登录是用什么来存储-token-的" aria-label="Permalink to &quot;项目中的登录是用什么来存储 token 的&quot;">​</a></h3><p>cookie</p><p>用户在浏览器输入账号密码，发送登录请求，服务端收到请求后，从数据库拿取数据来判断账号密码是否正确。在正确的情况下，服务器在向浏览器返回登录结果的时候，会生成一个 cookie，并且在 Http Response Header 中 Set-Cookie。这样，当浏览器再次向服务端发送请求时，都会同步的带上 cookie，cookie 会附带在每个 Http 请求上。</p><p>生成机制有两种：</p><ol><li><p>服务端生成，在 Http Response Header 中 Set-Cookie（GoCart 项目中使用的）</p></li><li><p>客户端生成，通过 document.cookie 设置</p></li></ol><h3 id="cookie-和-web-storage-localstorage、sessionstorage-的区别" tabindex="-1">cookie 和 Web Storage（localStorage、sessionStorage）的区别 <a class="header-anchor" href="#cookie-和-web-storage-localstorage、sessionstorage-的区别" aria-label="Permalink to &quot;cookie 和 Web Storage（localStorage、sessionStorage）的区别&quot;">​</a></h3><p>Cookie 设置初衷是用于<strong>维持 HTTP 状态</strong>，不用于存储数据，因此 cookie 有以下缺点：</p><ol><li>大小限制：每个 cookie 项只能存储 <strong>4K</strong> 数据</li><li>性能浪费：cookie 附带在 http 请求上，数据量过大，会导致每个 http 请求非常庞大，会很消耗流量和带宽。</li></ol><p>Web Storage <strong>专注存储</strong></p><p>localStorage</p><ul><li>特点：以域名维度，浏览器的<strong>持久化存储</strong>方案，在域名下一直存在，即使关闭会话窗口或浏览器，除非主动清理，否则永久存在；</li><li>大小：每个项可以存储 <strong>5M</strong> 的数据</li><li>接口：同步接口，会阻塞线程</li></ul><p>sessionStorage</p><ul><li>特点：以域名维度，浏览器基于<strong>会话级别的存储方案</strong>，它只有在当前会话窗口存储的数据才可以读取到，一旦关闭当前页面或新开一个窗口，之前存储的数据就获取不到了。刷新页面不会删除数据。</li><li>大小：每个项可以存储 <strong>5M</strong> 的数据</li><li>接口：同步接口，阻塞线程</li></ul><p>IndexedDB</p><ul><li>特点：以域名维度，网页只能访问自身域名下的存储的数据，不能跨域访问。不仅可以存储字符串，还可以存储二进制数据。</li><li>大小：每个项至少可以存储 <strong>250M</strong> 或无上限的数据</li><li>接口：异步接口，可以防止大量数据的读写拖慢网页的表现。</li><li>支持事务：不会出现只改写一部分数据的情况，出现失败，会回滚到事务发生之前的状态。</li></ul><h2 id="_6-react-常用的-hooks" tabindex="-1">6. React 常用的 Hooks <a class="header-anchor" href="#_6-react-常用的-hooks" aria-label="Permalink to &quot;6. React 常用的 Hooks&quot;">​</a></h2><p><strong>1. useState</strong></p><p>用于在函数组件中添加状态。状态（state）是变化的数据，是组件甚至前端应用的核心。useState 有传入值和函数两种参数，返回的 setState 也有传入值和函数两种参数。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 传入值</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#BABED8;">state</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> setState</span><span style="color:#89DDFF;">]</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">0</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 传入函数</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">[</span><span style="color:#BABED8;">num</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> setNum</span><span style="color:#89DDFF;">]</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">b</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">b</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">setState</span><span style="color:#BABED8;">(</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">setNum</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">state</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> state </span><span style="color:#89DDFF;">+</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 函数的参数是上一次的 state</span></span></code></pre></div><p><strong>2. useEffect</strong></p><p>用于在函数组件中执行副作用操作，例如 数据获取、订阅或手动更改 React 组件的 DOM 等。副作用 effect 函数是在渲染之外额外执行的一些逻辑。它是根据第二个参数的依赖数组是否变化来决定是否执行 effect，可以返回一个清理函数，会在组件卸载前执行或每次使用更改的依赖项重新渲染之前运行。</p><p>执行时机：在渲染结束之后</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">useEffect</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">timer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#BABED8;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">num</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">5000</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// 清理函数</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">clearTimeout</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">timer</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#BABED8;"> [num])</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 如果不传第二个参数时，每次都会执行；传递第二个参数时，第二个参数有变化时执行</span></span></code></pre></div><ol start="3"><li>useLayoutEffect</li></ol><p>和 useEffect 差不多，但是 useEffect 的 effect 函数是异步执行的，所以可能中间有次渲染会闪屏。而 useLayoutEffect 是同步执行的，所以不会闪屏，但如果计算量大可能会导致掉帧，阻塞渲染。所以，仅当在浏览器渲染之前运行效果至关重要时才需要此功能，例如：在用户看到工具提示之前测量和定位工具提示。（只有在关键时刻需要在用户看到之前运行你的 Effect 时才需要使用它，例如，在显示提示工具提示之前测量和定位位置。）</p><ol start="4"><li>useInsertionEffect</li></ol><p>回调函数会在 commit 阶段的 Mutation 子阶段同步执行，与 useLayoutEffect 的区别在于执行的时候无法访问 DOM 的引用。这个 Hook 是专门为 CSS-in-JS 库插入全局的 style 元素而设计。</p><p><strong>5. useReducer</strong></p><p>用于在函数组件中管理复杂的状态逻辑。它接受一个 reducer 函数和一个初始状态值作为参数，并返回一个包含当前状态和一个更新状态的 dispatch 函数的数组。使用 useReducer 可以更好地组织和管理状态更新逻辑，特别是在处理多个状态变量或执行异步操作时。</p><p>封装一些修改状态的逻辑到 reducer，通过 action 触发。当修改深层对象的时候，创建新对象比较麻烦，可以结合 immer 来解决。</p><p><strong>6. useRef</strong></p><p>可以保存 dom 引用或其他内容，通过<code>.current</code>来取，改变它的内容不会触发重新渲染。</p><p>返回一个可变的 ref 对象，其.current 属性被初始化为传入的参数。返回的 ref 对象在组件的整个生命周期内保持不变。这对于管理 DOM 对象、定时器或其他需要在组件生命周期内保持引用的值很有用。</p><ol start="7"><li>forwardRef + useImperativeHandle</li></ol><p>通过 forwardRef 可以从子组件转发 ref 到父组件。如果想自定义 ref 内容可以使用 useImperativeHandle 来实现。</p><p><strong>8. useContext</strong></p><p>用于在函数组件中访问 React 的 Context API。它接受一个 Context 对象作为参数，并返回该 Context 的当前值。这样，你可以在函数组件中使用 Context，而无需手动传递 props。</p><p><strong>9. memo + useMemo + useCallback</strong></p><p>memo 包裹的组件只有在 props 变化的时候才会重新渲染，useMemo、useCallback 可以防止 props 不必要的变化，两者一般是结合使用。不过当用来缓存计算结果等场景的时候，也可以单独使用 useMemo、useCallback。</p><p>useMemo 返回一个记忆化的值，该值只在依赖项数组发生变化时才会重新计算。这对于避免重复计算和提高性能很有用。</p><p>useCallback 返回一个记忆化的版本的回调函数，该回调函数在依赖项数组发生变化时才会更新。这对于防止不必要的渲染和提高性能很有用。</p><h3 id="补充提问-说一说-useeffect-和-uselayouteffect-的区别" tabindex="-1">补充提问：说一说 useEffect 和 useLayoutEffect 的区别 <a class="header-anchor" href="#补充提问-说一说-useeffect-和-uselayouteffect-的区别" aria-label="Permalink to &quot;补充提问：说一说 useEffect 和 useLayoutEffect 的区别&quot;">​</a></h3><p>在 React 中，用于定义有副作用因变量的 Hook 有：</p><ul><li>useEffect：回调函数会<strong>在 commit 阶段完成后异步执行</strong>，所以不会阻塞视图渲染</li><li>useLayoutEffect：回调函数会<strong>在 commit 阶段的 Layout 子阶段同步执行</strong>，一般用于执行 DOM 相关的操作。所以如果计算量大可能会导致掉帧，阻塞渲染。</li></ul><p>所以 useLayoutEffect 会比 useEffect 先执行。</p><p>每一个 effect 会与当前 FC 其他的 effect 形成环状链表，连接方式为单向环状链表。</p><p>其中 useEffect 工作流程可以分为：</p><ul><li>声明阶段</li><li>调度阶段</li><li>执行阶段</li></ul><p>useLayoutEffect 的工作流程可以分为：</p><ul><li>声明阶段</li><li>执行阶段</li></ul><p>之所以 useEffect 会比 useLayoutEffect 多一个阶段，就是因为 useEffect 的回调函数会在 commit 阶段完成后异步执行，因此需要经历调度阶段。</p><h2 id="_7-虚拟-dom" tabindex="-1">7. 虚拟 DOM <a class="header-anchor" href="#_7-虚拟-dom" aria-label="Permalink to &quot;7. 虚拟 DOM&quot;">​</a></h2><p><strong>虚拟 DOM 是什么？</strong></p><p>虚拟 DOM 最早是由 React 团队提出来的，这是一种编程思想，指的是针对真实 UI DOM 的一种描述能力。 在 React 中，使用了 JS 对象来描述真实的 DOM 结构。虚拟 DOM 和 JS 对象之间的关系：前者是一种思想，后者是一种思想的具体实现。</p><h3 id="虚拟-dom-的优势" tabindex="-1">虚拟 DOM 的优势 <a class="header-anchor" href="#虚拟-dom-的优势" aria-label="Permalink to &quot;虚拟 DOM 的优势&quot;">​</a></h3><p>使用虚拟 DOM 主要有两个方面的优势：</p><ol><li>相较于 DOM 的体积优势和速度优势</li><li>多平台渲染的抽象能力</li></ol><h4 id="_1-相较于-dom-的体积优势和速度优势" tabindex="-1">1. 相较于 DOM 的体积优势和速度优势 <a class="header-anchor" href="#_1-相较于-dom-的体积优势和速度优势" aria-label="Permalink to &quot;1. 相较于 DOM 的体积优势和速度优势&quot;">​</a></h4><ul><li>JS 层面的计算速度要比 DOM 层面的计算快得多 <ul><li>DOM 对象最终被浏览器渲染出来之前，浏览器会有很多工作要做（浏览器渲染原理）</li><li>DOM 对象上面的属性非常多</li></ul></li><li>虚拟 DOM 发挥优势的时机主要体现在更新阶段，相比较 innerHTML 要将已有的 DOM 节点全部销毁，虚拟 DOM 能够做到针对 DOM 节点做最小程度的修改</li></ul><h4 id="_2-多平台渲染的抽象能力" tabindex="-1">2. 多平台渲染的抽象能力 <a class="header-anchor" href="#_2-多平台渲染的抽象能力" aria-label="Permalink to &quot;2. 多平台渲染的抽象能力&quot;">​</a></h4><ul><li>浏览器、Node.js 宿主环境使用 ReactDOM 包</li><li>Native 宿主环境使用 ReactNative 包</li><li>Canvas、SVG 或者 VML（IE8）宿主环境使用 ReactArt 包</li><li>ReactTest 包用于渲染出 JS 对象，可以很方便的测试“不隶属于任何宿主环境的通用功能”</li></ul><p>在 React 中通过 JSX 来描述 UI，JSX 仅仅是一个语法糖，会被 Babel 编译为 createElement 方法的调用。该方法调用之后会返回一个 JS 对象，该对象就是虚拟 DOM 对象，官方更倾向于称之为一个 React 元素。</p><h3 id="虚拟-dom-的意义-来自哲玄" tabindex="-1">虚拟 DOM 的意义（来自哲玄）： <a class="header-anchor" href="#虚拟-dom-的意义-来自哲玄" aria-label="Permalink to &quot;虚拟 DOM 的意义（来自哲玄）：&quot;">​</a></h3><ol><li><p><strong>减少实际的 DOM 操作</strong>：通过比较新旧虚拟 DOM 树的差异，React 可以确定需要更新的部分，并生成最小化的 DOM 操作序列。这样可以减少实际的 DOM 操作，从而提高性能。</p></li><li><p><strong>批量更新</strong>：React 会将所有的更新都收集起来，等到下次渲染的时候，一次性的更新 DOM。从而避免了频繁的 DOM 操作，提高了性能。</p></li><li><p><strong>跨平台的兼容性</strong>：虚拟 DOM 是一个轻量级的 JavaScript 对象，可以在不同的平台上运行，例如浏览器、移动设备和服务器。这使得 React 可以在多个环境中使用相同的代码和逻辑。</p></li><li><p><strong>更好的开发体验</strong>：虚拟 DOM 使得开发者可以使用类似于 HTML 的标记语言来描述 UI，而不需要直接操作 DOM。这简化了开发过程，并提供了更好的开发体验。</p></li></ol><h2 id="_8-react-diff-算法" tabindex="-1">8. React diff 算法 <a class="header-anchor" href="#_8-react-diff-算法" aria-label="Permalink to &quot;8. React diff 算法&quot;">​</a></h2><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight has-diff"><code><span class="line"><span style="color:#676E95;font-style:italic;">// diff 算法是一种用于比较新旧虚拟 DOM 树的差异的算法，目标是找出需要更新的部分，并生成一个最小化的 DOM 操作序列。</span></span></code></pre></div><p>diff 计算发生在更新阶段，当第一次渲染完成后，就会产生 Fiber 树，再次渲染的时候（更新），就会拿新的 JSX 对象（vdom）和旧的 FiberNode 节点进行一个对比，再决定如何来产生新的 FiberNode，它的目标是尽可能的复用已有的 Fiber 节点。这个就是 diff 算法。</p><p>在 React 中整个 diff 分为单节点 diff 和多节点 diff。</p><p>所谓单节点是指新的节点为单一节点，但是旧节点的数量是不一定的。</p><p>单节点 diff 是否能够复用遵循如下的顺序：</p><ol><li>判断 key 是否相同</li></ol><ul><li>如果更新前后均未设置 key，则 key 均为 null，也属于相同的情况</li><li>如果 key 相同，进入步骤 2</li><li>如果 key 不同，则无需判断 type，结果为不能复用（有兄弟节点还会去遍历兄弟节点）</li></ul><ol start="2"><li>如果 key 相同，再判断 type 是否相同</li></ol><ul><li>如果 type 相同，那么就复用</li><li>如果 type 不同，则无法复用（并且兄弟节点也一并标记为删除）</li></ul><p>多节点 diff 会分为两轮遍历：</p><p>第一轮遍历会从前往后进行遍历，存在以下三种情况：</p><ul><li>如果新旧子节点的 key 和 type 都相同，说明可以复用</li><li>如果新旧子节点的 key 相同，但是 type 不同，这个时候就会根据 ReactElement 来生成一个全新的 fiber，旧的 fiber 被放入到 deletions 数组里面，回头统一删除。但是注意，此时遍历并不会终止</li><li>如果新旧子节点的 key 和 type 都不相同，结束遍历</li></ul><p>如果第一轮遍历被提前终止了，那么意味着还有新的 JSX 元素或者旧的 FiberNode 没有被遍历，因此会采用第二轮遍历去处理。</p><p>第二轮遍历会遇到三种情况：</p><ul><li>只剩下旧子节点：将旧的子节点添加到 deletions 数组里面直接删除（删除的情况）</li><li>只剩下新的 JSX 元素：根据 ReactElement 元素来创建 FiberNode 节点（新增的情况）</li><li>新旧子节点都有剩余：会将剩余的 FiberNode 节点放入一个 map 里面，遍历剩余的新的 JSX 元素，然后从 map 中去寻找能够复用的 FiberNode 节点，如果能够找到，就拿来复用（移动的情况） 如果不能找到，就新增。然后如果剩余的 JSX 元素都遍历完了，map 结构中还有剩余的 Fiber 节点，就将这些 Fiber 节点添加到 deletions 数组里面，之后统一做删除操作。</li></ul><p>整个 diff 算法最核心的就是两个字“复用”。</p><p>React 不使用双端 diff 的原因：</p><p>由于双端 diff 需要向前查找节点，但每个 FiberNode 节点上都没有反向指针，即前一个 FiberNode 通过 sibling 属性指向后一个 FiberNode，只能从前往后遍历，而不能反过来，因此该算法无法通过双端搜索来进行优化。 React 想看下现在用这种方式能走多远，如果这种方式不理想，以后再考虑实现双端 diff。React 认为对于列表反转和需要进行双端搜索的场景是少见的，所以在这一版的实现中，先不对 bad case 做额外的优化。</p>`,155),e=[p];function t(c,r,y,F,D,i){return a(),n("div",null,e)}const E=s(o,[["render",t]]);export{A as __pageData,E as default};
