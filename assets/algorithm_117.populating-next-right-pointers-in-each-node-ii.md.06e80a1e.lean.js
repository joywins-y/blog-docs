import{_ as t,H as e,o as c,c as r,C as s,J as a,E as p,a as n,V as o}from"./chunks/framework.bd00fe0c.js";const g=JSON.parse('{"title":"117. 填充每个节点的下一个右侧节点指针 II","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/117.populating-next-right-pointers-in-each-node-ii.md","filePath":"algorithm/117.populating-next-right-pointers-in-each-node-ii.md","lastUpdated":1698995422000}'),y={name:"algorithm/117.populating-next-right-pointers-in-each-node-ii.md"},D=o("",7),i=s("p",null,[s("strong",null,"示例 2：")],-1),F=o("",7);function B(E,A,f,u,d,h){const l=e("font");return c(),r("div",null,[D,s("blockquote",null,[s("p",null,[s("strong",null,[a(l,{color:"#000"},{default:p(()=>[n("输入")]),_:1})]),n("：root = [1,2,3,4,5,null,7]")]),s("p",null,[s("strong",null,[a(l,{color:"#000"},{default:p(()=>[n("输出")]),_:1})]),n("：[1,#,2,3,#,4,5,7,#]")]),s("p",null,[s("strong",null,[a(l,{color:"#000"},{default:p(()=>[n("解释")]),_:1})]),n("：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。")])]),i,s("blockquote",null,[s("p",null,[s("strong",null,[a(l,{color:"#000"},{default:p(()=>[n("输入")]),_:1})]),n("：root = []")]),s("p",null,[s("strong",null,[a(l,{color:"#000"},{default:p(()=>[n("输出")]),_:1})]),n("：[]")])]),F])}const N=t(y,[["render",B]]);export{g as __pageData,N as default};
