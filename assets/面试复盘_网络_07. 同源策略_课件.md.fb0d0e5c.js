import{_ as t,o as r,c as e,V as a}from"./chunks/framework.bd00fe0c.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"面试复盘/网络/07. 同源策略/课件.md","filePath":"面试复盘/网络/07. 同源策略/课件.md","lastUpdated":1712573589000}'),d={name:"面试复盘/网络/07. 同源策略/课件.md"},o=a('<p>浏览器有一个重要的安全策略，称之为「同源策略」</p><p>其中，$源=协议+主机+端口$，两个源相同，称之为同源，两个源不同，称之为跨源或跨域</p><p>比如：</p><table><thead><tr><th>源 1</th><th>源 2</th><th>是否同源</th></tr></thead><tbody><tr><td><a href="http://www.baidu.com" target="_blank" rel="noreferrer">http://www.baidu.com</a></td><td><a href="http://www.baidu.com/news" target="_blank" rel="noreferrer">http://www.baidu.com/news</a></td><td>✅</td></tr><tr><td><a href="https://www.baidu.com" target="_blank" rel="noreferrer">https://www.baidu.com</a></td><td><a href="http://www.baidu.com" target="_blank" rel="noreferrer">http://www.baidu.com</a></td><td>❌</td></tr><tr><td><a href="http://localhost:5000" target="_blank" rel="noreferrer">http://localhost:5000</a></td><td><a href="http://localhost:7000" target="_blank" rel="noreferrer">http://localhost:7000</a></td><td>❌</td></tr><tr><td><a href="http://localhost:5000" target="_blank" rel="noreferrer">http://localhost:5000</a></td><td><a href="http://127.0.0.1:5000" target="_blank" rel="noreferrer">http://127.0.0.1:5000</a></td><td>❌</td></tr><tr><td><a href="http://www.baidu.com" target="_blank" rel="noreferrer">http://www.baidu.com</a></td><td><a href="http://baidu.com" target="_blank" rel="noreferrer">http://baidu.com</a></td><td>❌</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p><strong>同源策略是指，若页面的源和页面运行过程中加载的源不一致时，出于安全考虑，浏览器会对跨域的资源访问进行一些限制</strong></p><p><img src="http://mdrs.yuanjin.tech/img/20210916104747.png" alt="image-20210916104747296"></p><p>同源策略对 ajax 的跨域限制的最为<em>凶狠</em>，默认情况下，它不允许 ajax 访问跨域资源</p><p><img src="http://mdrs.yuanjin.tech/img/20210916105741.png" alt="image-20210916105741041"></p><p>所以，我们通常所说的跨域问题，就是同源策略对 ajax 产生的影响</p><p>有多种方式解决跨域问题，常见的有：</p><ul><li><strong>代理</strong>，常用</li><li><strong>CORS</strong>，常用</li><li>JSONP</li></ul><p>无论使用哪一种方式，都是要让浏览器知道，我这次跨域请求的是自己人，就不要拦截了。</p>',12),p=[o];function h(l,n,s,c,i,_){return r(),e("div",null,p)}const f=t(d,[["render",h]]);export{m as __pageData,f as default};
