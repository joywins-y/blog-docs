import{_ as s,o as l,c as n,V as a}from"./chunks/framework.bd00fe0c.js";const d=JSON.parse('{"title":"React 渲染流程","description":"","frontmatter":{},"headers":[],"relativePath":"面试复盘/React/React 渲染流程.md","filePath":"面试复盘/React/React 渲染流程.md","lastUpdated":1710918713000}'),p={name:"面试复盘/React/React 渲染流程.md"},o=a(`<h1 id="react-渲染流程" tabindex="-1">React 渲染流程 <a class="header-anchor" href="#react-渲染流程" aria-label="Permalink to &quot;React 渲染流程&quot;">​</a></h1><blockquote><p>面试题：是否了解过 React 的整体渲染流程？里面主要有哪些阶段？</p></blockquote><p>现代前端框架都可以总结为一个公式：</p><blockquote><p>UI = f（state）</p></blockquote><p>上面的公式还可以进行一个拆分：</p><ul><li>根据自变量（state）的变化计算出 UI 的变化</li><li>根据 UI 变化执行具体的宿主环境的 API</li></ul><p>对应的公式：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> state </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">reconcile</span><span style="color:#BABED8;">(update)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 通过 reconciler 计算出最新的状态</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> UI </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">commit</span><span style="color:#BABED8;">(state)</span><span style="color:#89DDFF;">;</span><span style="color:#BABED8;"> </span><span style="color:#676E95;font-style:italic;">// 根据上一步计算出来的 state 渲染出 UI</span></span></code></pre></div><p>对应到 React 里面就两大阶段：</p><ul><li>render 阶段：调合虚拟 DOM，计算出最终要渲染出来的虚拟 DOM</li><li>commit 阶段：根据上一步计算出来的虚拟 DOM，渲染具体的 UI</li></ul><p>每个阶段对应不同的组件：</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2023-02-23-101849.png" alt="image-20230223181848783" style="zoom:50%;"><ul><li>调度器（Scheduer）：调度任务，为任务排序优先级，让优先级高的任务先进入到 Reconciler</li><li>协调器（Reconciler）：生成 Fiber 对象，收集副作用，找出哪些节点发生了变化，打上不同的 flags，著名的 diff 算法也是在这个组件中执行的。</li><li>渲染器（Renderer）：根据协调器计算出来的虚拟 DOM 同步的渲染节点到视图上。</li></ul><p>接下来我们来看一个例子：</p><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#BABED8;">count</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">updateCount</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#BABED8;">            </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={()</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">updateCount</span><span style="color:#BABED8;">(count </span><span style="color:#89DDFF;">+</span><span style="color:#BABED8;"> </span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;">)</span><span style="color:#89DDFF;">}&gt;</span><span style="color:#BABED8;">乘以</span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;">count</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#BABED8;">            </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;{</span><span style="color:#F78C6C;">1</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">*</span><span style="color:#BABED8;"> count</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#BABED8;">            </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;{</span><span style="color:#F78C6C;">2</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">*</span><span style="color:#BABED8;"> count</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#BABED8;">            </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;{</span><span style="color:#F78C6C;">3</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">*</span><span style="color:#BABED8;"> count</span><span style="color:#89DDFF;">}&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#BABED8;">        </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">    )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><p>当用户点击按钮时，首先是由 Scheduler 进行任务的协调，render 阶段（虚线框内）的工作流程是可以随时被以下原因中断：</p><ul><li>有其他更高优先级的任务需要执行</li><li>当前的 time slice 没有剩余的时间</li><li>发生了其他错误</li></ul><p>注意上面 render 阶段的工作是在内存里面进行的，不会更新宿主环境 UI，因此这个阶段即使工作流程反复被中断，用户也不会看到“更新不完整的 UI”。</p><p>当 Scheduler 调度完成后，将任务交给 Reconciler，Reconciler 就需要计算出新的 UI，最后就由 Renderer <strong>同步</strong>进行渲染更新操作。</p><p>如下图所示：</p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2023-02-23-103449.png" alt="image-20230223183449668" style="zoom:55%;"><h2 id="调度器" tabindex="-1">调度器 <a class="header-anchor" href="#调度器" aria-label="Permalink to &quot;调度器&quot;">​</a></h2><p>在 React v16 版本之前，采用的是 Stack 架构，所有任务只能同步进行，无法被打断，这就导致浏览器可能会出现丢帧的现象，表现出卡顿。React 为了解决这个问题，从 v16 版本开始从架构上面进行了两大更新：</p><ul><li>引入 Fiber</li><li>新增了 Scheduler</li></ul><p>Scheduler 在浏览器的原生 API 中实际上是有类似的实现的，这个 API 就是 requestIdleCallback</p><blockquote><p>MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback</a></p></blockquote><p>虽然每一帧绘制的时间约为 16.66ms，但是如果屏幕没有刷新，那么浏览器会安排长度为 50ms 左右的空闲时间。</p><p>为什么是 50ms？</p><p>根据研究报告表明，用户操作之后，100ms 以内的响应给用户的感觉都是瞬间发生，也就是说不会感受到延迟感，因此将空闲时间设置为 50，浏览器依然还剩下 50ms 可以处理用户的操作响应，不会让用户感到延迟。</p><p>虽然浏览器有类似的 API，但是 React 团队并没有使用该 API，因为该 API 存在兼容性问题。因此 React 团队自己实现了一套这样的机制，这个就是调度器 Scheduler。</p><p>后期 React 团队打算单独发行这个 Scheduler，这意味着调度器不仅仅只能在 React 中使用，凡是有涉及到任务调度需求的项目都可以使用 Scheduler。</p><h2 id="协调器" tabindex="-1">协调器 <a class="header-anchor" href="#协调器" aria-label="Permalink to &quot;协调器&quot;">​</a></h2><p>协调器是 render 阶段的第二阶段工作，类组件或者函数组件本身就是在这个阶段被调用的。</p><p>根据 Scheduler 调度结果的不同，协调器起点可能是不同的</p><ul><li>performSyncWorkOnRoot（同步更新流程）</li><li>performConcurrentWorkOnRoot（并发更新流程）</li></ul><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// performSyncWorkOnRoot 会执行该方法</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">workLoopSync</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">workInProgress</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">performUnitOfWork</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">workInProgress</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// performConcurrentWorkOnRoot 会执行该方法</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">workLoopConcurrent</span><span style="color:#89DDFF;">()</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">workInProgress</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!==</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">null</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">!</span><span style="color:#82AAFF;">shouldYield</span><span style="color:#F07178;">()) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">performUnitOfWork</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">workInProgress</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>新的架构使用 Fiber（对象）来描述 DOM 结构，最终需要形成一颗 Fiber tree，这不过这棵树是通过链表的形式串联在一起的。</p><p>workInProgress 代表的是当前的 FiberNode。</p><p>performUnitOfWork 方法会创建下一个 FiberNode，并且还会将已创建的 FiberNode 连接起来（child、return、sibling），从而形成一个链表结构的 Fiber tree。</p><p>如果 workInProgress 为 null，说明已经没有下一个 FiberNode，也就是说明整颗 Fiber tree 树已经构建完毕。</p><p>上面两个方法唯一的区别就是是否调用了 shouldYield 方法，该方法表明了是否可以中断。</p><p>performUnitOfWork 在创建下一个 FiberNode 的时候，整体上的工作流程可以分为两大块：</p><ul><li>递阶段</li><li>归阶段</li></ul><p><strong>递阶段</strong></p><p>递阶段会从 HostRootFiber 开始向下以深度优先的原则进行遍历，遍历到的每一个 FiberNode 执行 beginWork 方法。该方法会根据传入的 FiberNode 创建下一级的 FiberNode，此时可能存在两种情况：</p><ul><li>下一级只有一个元素，beginWork 方法会创建对应的 FiberNode，并于 workInProgress 连接</li></ul><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>这里就会创建 li 对应的 FiberNode，做出如下的连接：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#BABED8;">LiFiber</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">return </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> UlFiber</span><span style="color:#89DDFF;">;</span></span></code></pre></div><ul><li>下一级有多个元素，这是 beginWork 方法会依次创建所有的子 FiberNode 并且通过 sibling 连接到一起，每个子 FiberNode 也会和 workInProgress 连接</li></ul><div class="language-jsx"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><p>此时会创建 3 个 li 对应的 FiberNode，连接情况如下：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 所有的子 Fiber 依次连接</span></span>
<span class="line"><span style="color:#BABED8;">Li0Fiber</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">sibling </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> Li1Fiber</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">Li1Fiber</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">sibling </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> Li2Fiber</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 子 Fiber 还需要和父 Fiber 连接</span></span>
<span class="line"><span style="color:#BABED8;">Li0Fiber</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">return </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> UlFiber</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">Li1Fiber</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">return </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> UlFiber</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#BABED8;">Li2Fiber</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">return </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> UlFiber</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>由于采用的是深度优先的原则，因此无法再往下走的时候，会进入到归阶段。</p><p><strong>归阶段</strong></p><p>归阶段会调用 completeWork 方法来处理 FiberNode，做一些副作用的收集。</p><p>当某个 FiberNode 执行完了 completeWork 方法后，如果存在兄弟元素，就会进入到兄弟元素的递阶段，如果不存在兄弟元素，就会进入父 FiberNode 的归阶段。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">performUnitOfWork</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">fiberNode</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 省略 beginWork</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">fiberNode</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">child</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">performUnitOfWork</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">fiberNode</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">child</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 省略 CompleteWork</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#BABED8;">fiberNode</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">sibling</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#82AAFF;">performUnitOfWork</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">fiberNode</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">sibling</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>最后我们来看一张图：</p><p><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2023-02-24-031518.png" alt="image-20230224111517826"></p><h2 id="渲染器" tabindex="-1">渲染器 <a class="header-anchor" href="#渲染器" aria-label="Permalink to &quot;渲染器&quot;">​</a></h2><p>Renderer 工作的阶段被称之为 commit 阶段。该阶段会将各种副作用 commit 到宿主环境的 UI 中。</p><p>相较于之前的 render 阶段可以被打断，commit 阶段一旦开始就会<strong>同步</strong>执行直到完成渲染工作。</p><p>整个渲染器渲染过程中可以分为三个子阶段：</p><ul><li>BeforeMutation 阶段</li><li>Mutation 阶段</li><li>Layout 阶段</li></ul><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2023-03-02-090354.png" alt="image-20230302170353345" style="zoom:50%;"><h2 id="真题解答" tabindex="-1">真题解答 <a class="header-anchor" href="#真题解答" aria-label="Permalink to &quot;真题解答&quot;">​</a></h2><blockquote><p>题目：是否了解过 React 的整体渲染流程？里面主要有哪些阶段？</p><p>参考答案：</p><p>React 整体的渲染流程可以分为两大阶段，分别是 render 阶段和 commit 阶段。</p><p>render 阶段里面会经由调度器和协调器处理，此过程是在内存中运行，是异步可中断的。</p><p>commit 阶段会由渲染器进行处理，根据副作用进行 UI 的更新，此过程是同步不可中断的，否则会造成 UI 和数据显示不一致。</p><p><strong>调度器</strong></p><p>调度器的主要工作就是调度任务，让所有的任务有优先级的概念，这样的话紧急的任务可以优先执行。Scheduler 实际上在浏览器的 API 中是有原生实现的，这个 API 叫做 requestIdleCallback，但是由于兼容性问题，React 放弃了使用这个 API，而是自己实现了一套这样的机制，并且后期会把 Scheduler 这个包单独的进行发布，变成一个独立的包。这就意味 Scheduler 不仅仅是只能在 React 中使用，后面如果有其他的项目涉及到了任务调度的需求，都可以使用这个 Scheduler。</p><p><strong>协调器</strong></p><p>协调器是 Render 的第二阶段工作。该阶段会采用深度优先的原则遍历并且创建一个一个的 FiberNode，并将其串联在一起，在遍历时分为了“递”与“归”两个阶段，其中在“递”阶段会执行 beginWork 方法，该方法会根据传入的 FiberNode 创建下一级 FiberNode。而“归”阶段则会执行 CompleteWork 方法，做一些副作用的收集</p><p><strong>渲染器</strong></p><p>渲染器的工作主要就是将各种副作用（flags 表示）commit 到宿主环境的 UI 中。整个阶段可以分为三个子阶段，分别是 BeforeMutation 阶段、Mutation 阶段和 Layout 阶段。</p></blockquote>`,69),e=[o];function t(r,c,F,i,y,D){return l(),n("div",null,e)}const u=s(p,[["render",t]]);export{d as __pageData,u as default};
